<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>plonk-tutorial</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="PlonK-Tutorial_files/libs/clipboard/clipboard.min.js"></script>
<script src="PlonK-Tutorial_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="PlonK-Tutorial_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="PlonK-Tutorial_files/libs/quarto-html/popper.min.js"></script>
<script src="PlonK-Tutorial_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="PlonK-Tutorial_files/libs/quarto-html/anchor.min.js"></script>
<link href="PlonK-Tutorial_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="PlonK-Tutorial_files/libs/quarto-html/quarto-syntax-highlighting-1b3e43c72e8be34557c75123b0b69e0d.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="PlonK-Tutorial_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="PlonK-Tutorial_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="PlonK-Tutorial_files/libs/bootstrap/bootstrap-e296c830b82ee2ceecc5d0be9cc60d75.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#how-to-mathcalp-mathfraklon-mathcalk" id="toc-how-to-mathcalp-mathfraklon-mathcalk" class="nav-link active" data-scroll-target="#how-to-mathcalp-mathfraklon-mathcalk">How to <span class="math inline">\(\mathcal{P} \mathfrak{lon} \mathcal{K}\)</span></a>
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">1.Introduction</a></li>
  <li><a href="#a-first-example" id="toc-a-first-example" class="nav-link" data-scroll-target="#a-first-example">2.A first example</a>
  <ul>
  <li><a href="#fibonacci-example" id="toc-fibonacci-example" class="nav-link" data-scroll-target="#fibonacci-example">Fibonacci Example</a></li>
  <li><a href="#interpolation-and-zero-equality-tests" id="toc-interpolation-and-zero-equality-tests" class="nav-link" data-scroll-target="#interpolation-and-zero-equality-tests">Interpolation and Zero-equality tests</a>
  <ul class="collapse">
  <li><a href="#selectors" id="toc-selectors" class="nav-link" data-scroll-target="#selectors">Selectors</a></li>
  <li><a href="#wiring-constraints" id="toc-wiring-constraints" class="nav-link" data-scroll-target="#wiring-constraints">Wiring constraints</a></li>
  </ul></li>
  <li><a href="#alternative-zero-equality-testing" id="toc-alternative-zero-equality-testing" class="nav-link" data-scroll-target="#alternative-zero-equality-testing">Alternative zero-equality testing</a>
  <ul class="collapse">
  <li><a href="#recap-and-first-protocol" id="toc-recap-and-first-protocol" class="nav-link" data-scroll-target="#recap-and-first-protocol">Recap and First Protocol</a>
  <ul class="collapse">
  <li><a href="#setup" id="toc-setup" class="nav-link" data-scroll-target="#setup">1. Setup</a></li>
  <li><a href="#prover-computation" id="toc-prover-computation" class="nav-link" data-scroll-target="#prover-computation">2. Prover Computation</a></li>
  <li><a href="#prover-verifier-communication" id="toc-prover-verifier-communication" class="nav-link" data-scroll-target="#prover-verifier-communication">3. Prover → Verifier Communication</a></li>
  <li><a href="#verifier-checks" id="toc-verifier-checks" class="nav-link" data-scroll-target="#verifier-checks">4. Verifier Checks</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  <li><a href="#towards-a-more-efficient-version" id="toc-towards-a-more-efficient-version" class="nav-link" data-scroll-target="#towards-a-more-efficient-version">3.Towards a more efficient version</a>
  <ul>
  <li><a href="#second-protocol-version-succinct-probabilistic-check" id="toc-second-protocol-version-succinct-probabilistic-check" class="nav-link" data-scroll-target="#second-protocol-version-succinct-probabilistic-check">Second Protocol Version (Succinct, Probabilistic Check)</a></li>
  <li><a href="#protocol-flow" id="toc-protocol-flow" class="nav-link" data-scroll-target="#protocol-flow">Protocol Flow</a></li>
  <li><a href="#diagram-of-protocol" id="toc-diagram-of-protocol" class="nav-link" data-scroll-target="#diagram-of-protocol">Diagram of Protocol</a></li>
  </ul></li>
  <li><a href="#an-even-more-efficient-version" id="toc-an-even-more-efficient-version" class="nav-link" data-scroll-target="#an-even-more-efficient-version">4.An even more efficient version</a>
  <ul>
  <li><a href="#pairings" id="toc-pairings" class="nav-link" data-scroll-target="#pairings">Pairings</a></li>
  <li><a href="#kzg-commitment" id="toc-kzg-commitment" class="nav-link" data-scroll-target="#kzg-commitment">KZG commitment</a></li>
  <li><a href="#new-protocol-version" id="toc-new-protocol-version" class="nav-link" data-scroll-target="#new-protocol-version">New Protocol Version</a></li>
  <li><a href="#setup-phase" id="toc-setup-phase" class="nav-link" data-scroll-target="#setup-phase">1. Setup Phase</a></li>
  <li><a href="#prover-computation-phase" id="toc-prover-computation-phase" class="nav-link" data-scroll-target="#prover-computation-phase">2. Prover Computation Phase</a></li>
  <li><a href="#verifier-challenge-phase" id="toc-verifier-challenge-phase" class="nav-link" data-scroll-target="#verifier-challenge-phase">3. Verifier Challenge Phase</a></li>
  <li><a href="#proof-verification-phase" id="toc-proof-verification-phase" class="nav-link" data-scroll-target="#proof-verification-phase">4. Proof &amp; Verification Phase</a></li>
  <li><a href="#protocol-diagram" id="toc-protocol-diagram" class="nav-link" data-scroll-target="#protocol-diagram">Protocol Diagram</a></li>
  </ul></li>
  <li><a href="#domains-and-selectors" id="toc-domains-and-selectors" class="nav-link" data-scroll-target="#domains-and-selectors">5.Domains and selectors</a></li>
  <li><a href="#copy-constraints" id="toc-copy-constraints" class="nav-link" data-scroll-target="#copy-constraints">6.Copy constraints</a></li>
  <li><a href="#towards-zkp" id="toc-towards-zkp" class="nav-link" data-scroll-target="#towards-zkp">7.Towards ZKP</a>
  <ul>
  <li><a href="#blinding-via-vanishing-polynomial-multiples" id="toc-blinding-via-vanishing-polynomial-multiples" class="nav-link" data-scroll-target="#blinding-via-vanishing-polynomial-multiples">Blinding via vanishing-polynomial multiples</a></li>
  <li><a href="#one-fresh-blinding-factor-per-opening" id="toc-one-fresh-blinding-factor-per-opening" class="nav-link" data-scroll-target="#one-fresh-blinding-factor-per-opening">One fresh blinding factor per opening</a></li>
  </ul></li>
  <li><a href="#fiat-shamir" id="toc-fiat-shamir" class="nav-link" data-scroll-target="#fiat-shamir">8.Fiat Shamir</a></li>
  <li><a href="#verifier" id="toc-verifier" class="nav-link" data-scroll-target="#verifier">Verifier</a></li>
  <li><a href="#recap-and-conclusions" id="toc-recap-and-conclusions" class="nav-link" data-scroll-target="#recap-and-conclusions">9.Recap and conclusions</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content column-page-right" id="quarto-document-content">




<section id="how-to-mathcalp-mathfraklon-mathcalk" class="level1">
<h1>How to <span class="math inline">\(\mathcal{P} \mathfrak{lon} \mathcal{K}\)</span></h1>
<p><em>Martín Ochoa, zkSecurity</em></p>
<p>Welcome to the PLONK tutorial! There are a couple alternative ways you can use this tutorial:</p>
<ul>
<li>You can download the <a href="code/notebook.zip">Jupyter Notebook</a> version and run it locally on a <a href="https://doc.sagemath.org/html/en/installation/launching.html">Sage kernel</a> or on the cloud on <a href="https://cocalc.com/">Cocalc</a>.</li>
<li>You can follow this page and implement the solutions locally in Sage or some other programming language. We aim at giving deterministic test cases to guide you.</li>
</ul>
<p><strong>Note</strong>: It is highly recommended you use Sage solve the exercises below in order to take advantage of its libraries, and of our implementation of the algebra needed for pairings over the bn254 curve.</p>
<p>If you have any feedback or comments do let us know at <em>martin<span class="math inline">\(@\)</span>zksecurity<span class="math inline">\(.\)</span>xyz</em>.</p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1.Introduction</h2>
<p>In this notebook we illustrate the <a href="https://eprint.iacr.org/2019/953.pdf">PLONK</a> zero-knowledge-proof protocol on a simple example that we will progressively make more complete. The goal is to understand the mathematical inner workings of the protocol, down to the level of cryptographic pairings and commitment schemes. The PLONK protocol has various phases each of which involves technical steps in order to achieve certain protocol subgoals.</p>
</section>
<section id="a-first-example" class="level2">
<h2 class="anchored" data-anchor-id="a-first-example">2.A first example</h2>
<p>Consider the following scenario: You have a low resource device <span class="math inline">\(V\)</span> (a <em>validator</em>) that can delegate computations to a <em>processor</em> <span class="math inline">\(P\)</span>, which has more computing capabilities. Sometimes the processor <span class="math inline">\(P\)</span> makes mistakes in the computations, so <span class="math inline">\(V\)</span> wants to do some sanity checks on <span class="math inline">\(V\)</span> to make sure the final value of the computation is correct.</p>
<section id="fibonacci-example" class="level4">
<h4 class="anchored" data-anchor-id="fibonacci-example">Fibonacci Example</h4>
<p>For example, let’s assume that <span class="math inline">\(V\)</span> asks <span class="math inline">\(P\)</span> to compute the <span class="math inline">\(4\)</span>-th Fibonacci number squared, that is <span class="math inline">\(F_{4}^2\)</span>. Recall that the Fibonacci sequence is defined by:</p>
<p><span class="math display">\[F_n = F_{n-1} + F_{n-2}\]</span></p>
<p>with the base cases <span class="math inline">\(F_0 = 0\)</span> and <span class="math inline">\(F_1 = 1\)</span>.</p>
<p>Note that this computation can be expressed as a circuit as illustrated in Figure 1.</p>
<center>
<img src="img_td/fibonacci_squared_circuit.png" width="600">
</center>
<p>The goal of this example will be to design a first simple protocol that allows us to validate whether this circuit has been correctly evaluated by the processor <span class="math inline">\(P\)</span> without having to recompute every single intermediate state (wire value) of the circuit. In other words the question is: can we devise a protocol that can (efficiently) guarantee that the <span class="math inline">\(F_{4}\)</span> value of the sequence has been correctly computed and then squared? Are the base cases <span class="math inline">\(F_0\)</span> and <span class="math inline">\(F_1\)</span> correct, and have all intermediate computations of the circuit correctly performed?</p>
<p>To achieve this, let us start by picturing the circuit and all intermediate computations as a table. Consider the following picture.</p>
<center>
<img src="img_td/fibonacci_s_table.png" width="350">
</center>
<p>Note that the condition that <span class="math inline">\(F_4^2\)</span> is correctly computed according to the Fibonacci recursive definition is equivalent to the following conditions:</p>
<ul>
<li>The left and right inputs to the first gate are <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> respectively.</li>
<li>For all gates 1 to 3 the output is computed as the sum of the left and right inputs</li>
<li>For gates 2 and 3 the left input of gate <span class="math inline">\(k\)</span> is equal to the right input to gate <span class="math inline">\(k-1\)</span> and the right input of gate <span class="math inline">\(k\)</span> is the output of gate <span class="math inline">\(k-1\)</span>.</li>
<li>For gate 4, the left and right inputs are the output of gate 3, and the output is the multiplication of the inputs.</li>
</ul>
<p>We can visualize this as follows:</p>
<center>
<img src="img_td/fibonacci_s_table2.png" width="350">
</center>
<p>Or mathematically, consider the set of indexes <span class="math inline">\(I=\{1,2,3,4\}\)</span> and denote the left inputs as a function <span class="math display">\[LI: I \to \mathbb{N}\]</span> and similarly the right inputs <span class="math inline">\(RI\)</span> and the outputs <span class="math inline">\(O\)</span>. Then we could say:</p>
<p><span class="math display">\[\begin{aligned}
&amp;LI(1)=0,\quad RI(1)=1,\\
&amp;\forall i \in I\setminus \{4\} : LI(i)+RI(i) = O(i),\\
&amp; \forall i \in I\setminus \{3,4\}:  \bigl(LI(i+1) = RI(i)\bigr)\;\wedge\;\bigl(RI(i+1)=O(i)\bigr),\\
&amp;LI(4)=RI(4) = O(3),\\   
&amp;LI(4)*RI(4) = O(4),\\
&amp;\implies\quad O(4) = F_4^2.
\end{aligned}\]</span></p>
<p>So if the processor <span class="math inline">\(P\)</span> can convince the validator <span class="math inline">\(V\)</span> that the above defined constraints hold for the table representation of the circuit computation, then the validator will be convinced that <span class="math inline">\(F_4^2\)</span> was computed correctly. Let us now explore a way to do so by leveraging on polynomials and so-called zero-equality tests.</p>
</section>
<section id="interpolation-and-zero-equality-tests" class="level3">
<h3 class="anchored" data-anchor-id="interpolation-and-zero-equality-tests">Interpolation and Zero-equality tests</h3>
<p>A trivial way for the verifier to check if the constraints on the circuit hold would be to get copies of <span class="math inline">\(LI,RI\)</span> and <span class="math inline">\(O\)</span> and check them. But this would defeat the purpose of delegating the computation, because the amount of work that the prover has to do is equivalent to recomputing <span class="math inline">\(F_4^2\)</span> on his own. To make this more efficient, consider the following encoding of the vectors <span class="math inline">\(LI,RI\)</span> and <span class="math inline">\(O\)</span>: suppose there was an easy way to transform those vectors into polynomials <span class="math inline">\(a(x),b(x),c(x)\)</span> such that, for every index <span class="math inline">\(i \in I\)</span>, <span class="math inline">\(a(i) = LI(i)\)</span>, <span class="math inline">\(b(i)= RI(i)\)</span> and <span class="math inline">\(c(i)=O(i)\)</span>.</p>
<p>If this was possible, then the processor <span class="math inline">\(P\)</span> could hand in <span class="math inline">\(a(x),b(x)\)</span> and <span class="math inline">\(c(x)\)</span> to the validator, who can compute:</p>
<p><span class="math display">\[ t(x) = a(x) + b(x) - c(x)\]</span></p>
<p>This polynomial has the property that for all indexes <span class="math inline">\(i \in I\setminus{4}\)</span>, <span class="math inline">\(t(i) = 0\)</span>.</p>
<p>Additionally, the validator needs to check that:</p>
<p><span class="math display">\[ t'(x) = a(x)*b(x) - c(x)\]</span></p>
<p>is zero for <span class="math inline">\(x=4\)</span>.</p>
<section id="selectors" class="level4">
<h4 class="anchored" data-anchor-id="selectors">Selectors</h4>
<p>In order to simplify those checks, PLONK introduces the so-called selector columns (and their respective polynomials as follows). Consider three boolean vectors <span class="math inline">\(SL, SR, SM\)</span> such that <span class="math inline">\(SL\)</span> and <span class="math inline">\(SR\)</span> are set if a given index contains an addition gate, and zero otherwise. Likewise, <span class="math inline">\(SM\)</span> will be set whenever there is a multiplication gate. Their polynomial version satisfy <span class="math inline">\(qL(i) = SL(i), qR(i)=SR(i), qM(i)=SM(i)\)</span>. Then we could compress checks for both addition and multiplication gates into one:</p>
<p><span class="math display">\[t(x)= qL(x) \cdot a(x) + qR(x) \cdot b(x) + qM(x) \cdot (a(x) \cdot b(x)) - c(x) \]</span></p>
<p>This polynomial should now be 0 for all <span class="math inline">\(i \in I\)</span>.</p>
</section>
<section id="wiring-constraints" class="level4">
<h4 class="anchored" data-anchor-id="wiring-constraints">Wiring constraints</h4>
<p>Moreover, we could also encode the missing constraints as follows:</p>
<p><span class="math display">\[ f_1(x) = a(x+1) - b(x)\]</span> <span class="math display">\[f_2(x) = b(x+1) - c(x)\]</span></p>
<p>These two should also be zero at all but the last two indexes, <span class="math inline">\(i \in I \setminus{\{3,4\}}\)</span>. Last we need to check:</p>
<p><span class="math display">\[f_3(x) = b(x) - c(x-1)\]</span></p>
<p><span class="math display">\[f_4(x) = a(x) - b(x)\]</span></p>
<p>which should hold for <span class="math inline">\(x=4\)</span>.</p>
<p>So by encoding the vectors <span class="math inline">\(L,R,O\)</span> into polynomials <span class="math inline">\(a(x),b(x),c(x)\)</span>, a validator <span class="math inline">\(V\)</span> could in principle check all that is needed to convince themselves that <span class="math inline">\(F_4^2 = c(4)\)</span> was computed correctly.</p>
<p><strong>Let us begin implementing these ideas</strong> before building our (still preliminary) validation protocol. Although mathematically the Fibonacci function is defined over the naturals <span class="math inline">\(\mathbb{N}\)</span>, when implementing zero-knowledge proofs we crucially do all arithmetic in a finite field <span class="math inline">\(\mathbb{F}_p\)</span>, meaning values are taken modulo a prime <span class="math inline">\(p\)</span>. There are various reasons why this is done. First, many cryptographic constructions rely on the difficulty of certain discrete problems over finite fields. Also, working on a field ensures every nonzero element has a multiplicative inverse, which will be useful in the following to reason about operations over polynomials. Last, arithmetic modulo <span class="math inline">\(p\)</span> is straightforward to implement and typically efficient.</p>
<p><strong>Exercise 1</strong> Represent the vectors <span class="math inline">\(LI,RI,O,SL,SR,SM\)</span> as polynomials <span class="math inline">\(a,b,c\)</span> over the finite field defined by <span class="math display">\[p = 21888242871839275222246405745257275088548364400416034343698204186575808495617.\]</span> This prime number is the order of the bn254 elliptic curve, which will be useful in the following. To interpolate the polynomials use Lagrange interpolation as follows. Given a set of points <span class="math inline">\(X = \{x_1,x_2,\dots,x_n\}\)</span> and data <span class="math inline">\((x_i,y_i)\)</span> for each <span class="math inline">\(i \in I\)</span>, the interpolating polynomial <span class="math inline">\(f(x)\)</span>:</p>
<p><span class="math display">\[
f(x)
=
\sum_{j \in I}
\Bigl(
  y_j
  \prod_{\substack{i \in I \\ i \neq j}}
  \frac{x - x_i}{x_j - x_i}
\Bigr)
\;\in\;\mathbb{F}_p[x].
\]</span></p>
<div id="ff9ca5ac-97c0-40f8-9b82-d6eca2a3745f" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interpolate(I, Y):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Solve here!</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="dv">21888242871839275222246405745257275088548364400416034343698204186575808495617</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> GF(p)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>R.<span class="op">&lt;</span>x<span class="op">&gt;</span> <span class="op">=</span> PolynomialRing(F, <span class="st">'x'</span>)   </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>LI <span class="op">=</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>RI <span class="op">=</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>O <span class="op">=</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>SL<span class="op">=</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>SR<span class="op">=</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>SM<span class="op">=</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>qL <span class="op">=</span> </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>qR <span class="op">=</span> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>qM <span class="op">=</span> </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If computed correctly you should be able to check the following properties on the polynomials:</p>
<ul>
<li>They are all polynomials of degree 3 over <span class="math inline">\(\mathbb{F}_p\)</span></li>
<li>When evaluated over the indexes <span class="math inline">\(I\)</span> you get the expected values as defined by <span class="math inline">\(L,R,O\)</span>.</li>
<li>When defining <span class="math inline">\(t = a(x) + b(x) - c(x)\)</span> you get 0 over the indexes <span class="math inline">\(I\)</span>.</li>
</ul>
<p>For example, the first polynomial is:</p>
<p><span class="math display">\[a(x) = 10944121435919637611123202872628637544274182200208017171849102093287904247809 x^{3} + 10944121435919637611123202872628637544274182200208017171849102093287904247805 x^{2} + 8 x + 21888242871839275222246405745257275088548364400416034343698204186575808495612\]</span></p>
<div id="abdc018e-6cab-45e0-a582-f0184d3009d4" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">all</span> <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> I:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">all</span> <span class="op">=</span> <span class="bu">all</span> <span class="kw">and</span> (a(i) <span class="op">==</span> LI[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Is a(x) correctly interpolated?"</span>, <span class="bu">all</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="bu">all</span> <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> I:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">all</span> <span class="op">=</span> <span class="bu">all</span> <span class="kw">and</span> (b(i) <span class="op">==</span> RI[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Is b(x) correctly interpolated?"</span>, <span class="bu">all</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="bu">all</span> <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> I:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">all</span> <span class="op">=</span> <span class="bu">all</span> <span class="kw">and</span> (c(i) <span class="op">==</span> O[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Is c(x) correctly interpolated?"</span>, <span class="bu">all</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="bu">all</span> <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> qM<span class="op">*</span>a<span class="op">*</span>b <span class="op">+</span> qL<span class="op">*</span>a<span class="op">+</span>qR<span class="op">*</span>b<span class="op">-</span>c</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> I:</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">all</span> <span class="op">=</span> <span class="bu">all</span> <span class="kw">and</span> (t(i) <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Is  t =qM*a*b + qL*a+qR*b-c zero over all indexes?"</span>, <span class="bu">all</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Is a(x) correctly interpolated? True
Is b(x) correctly interpolated? True
Is c(x) correctly interpolated? True
Is  t =qM*a*b + qL*a+qR*b-c zero over all indexes? True</code></pre>
</div>
</div>
<p>At this point we can also check the recursive constraints.</p>
<div id="7c7e199a-f6f1-4b82-88a7-4c368b5c89e6" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>f1 <span class="op">=</span> a(x<span class="op">+</span><span class="dv">1</span>)<span class="op">-</span>b(x)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">all</span> <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> I[:<span class="dv">2</span>]:</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">all</span> <span class="op">=</span> <span class="bu">all</span> <span class="kw">and</span> ( f1(i) <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Is f1(x) = a(x+1)- b(x) zero over all indexes minus the last?"</span>, <span class="bu">all</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>f2 <span class="op">=</span> b(x<span class="op">+</span><span class="dv">1</span>)<span class="op">-</span>c(x)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="bu">all</span> <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> I[:<span class="dv">2</span>]:</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">all</span> <span class="op">=</span> <span class="bu">all</span> <span class="kw">and</span> ( f1(i) <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Is f2(x) = b(x+1)- c(x) zero over all indexes minus the last?"</span>, <span class="bu">all</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Is f1(x) = a(x+1)- b(x) zero over all indexes minus the last? True
Is f2(x) = b(x+1)- c(x) zero over all indexes minus the last? True</code></pre>
</div>
</div>
</section>
</section>
<section id="alternative-zero-equality-testing" class="level3">
<h3 class="anchored" data-anchor-id="alternative-zero-equality-testing">Alternative zero-equality testing</h3>
<p>Now, remember we want to build a protocol that is more efficient than recomputing the original function. In the checks above, we were looping through the values of <span class="math inline">\(I\)</span> to check for zero equality. We can take advantage of the algebraic properties of the interpolated polynomials to do this in a different way, which will lead to a more efficient algorithm for arbitrary circuits.</p>
<p>In fact, since we are working on a field, we know that if <span class="math inline">\(t(x)=0\)</span> for every index <span class="math inline">\(i \in I\)</span>, then the polynomial <span class="math inline">\((x-i)\)</span> divides <span class="math inline">\(t(x)\)</span>, and therefore the polynomial <span class="math inline">\(Z(x) = \prod_{i \in I} (x-i)\)</span> divides <span class="math inline">\(t(x)\)</span>. Equivalently, there must exist a quotient polynomial <span class="math inline">\(Q(x) \in \mathbb{F}[x]\)</span> such that:</p>
<p><span class="math display">\[ t(x) = Q(x) \cdot Z(x)\]</span></p>
<p>Checking this relation for the right “vanishing” polynomial Z replaces the need for looping over all indexes.</p>
<p><strong>Exercise 2</strong>: Compute <span class="math inline">\(Z(x)\)</span> and quotient <span class="math inline">\(Q(x)\)</span> for <span class="math inline">\(t(x)\)</span>. Also compute <span class="math inline">\(Z'(x)\)</span> for <span class="math inline">\(I' = I \setminus{\{3,4\}}\)</span> and the corresponding <span class="math inline">\(Q_1(x)\)</span> and <span class="math inline">\(Q_2(x)\)</span> for the recursive constraint polynomials <span class="math inline">\(f_1\)</span> and <span class="math inline">\(f_2\)</span>.</p>
<div id="875f7e85-ae2e-4b41-899d-2afcf0fa9932" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>Z1 <span class="op">=</span> </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>Q1 <span class="op">=</span> </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>Q2 <span class="op">=</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If computed correctly you should get:</p>
<p><span class="math display">\[Q(x) = 304003373219989933642311190906351042896505061116889365884697280369108451328 x^{5} + 18240202393199396018538671454381062573790303667013361953081836822146507079681 x^{4} + 15504172034219486615757870736223903187721758116961357660119561298824531017728 x^{3} + 12160134928799597345692447636254041715860202444675574635387891214764338053122 x^{2} + 7296080957279758407415468581752425029516121466805344781232734728858602831871 x + 7296080957279758407415468581752425029516121466805344781232734728858602831873
\]</span></p>
<p>We can also do the sanity check of recovering <span class="math inline">\(t\)</span> from <span class="math inline">\(Q\)</span> and <span class="math inline">\(Z\)</span>.</p>
<div id="38c13d50" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Is t(x) = Q(x) * Z(x)?"</span>, t <span class="op">==</span> Q<span class="op">*</span>Z)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>show(<span class="st">"Q="</span>,Q)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Is f1(x) = Q1(x) * Z1(x)?"</span>, f1 <span class="op">==</span> Q1<span class="op">*</span>Z1)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>show(<span class="st">"Q1="</span>,Q1)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Is f2(x) = Q2(x) * Z1(x)?"</span>, f2 <span class="op">==</span> Q2<span class="op">*</span>Z1)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>show(<span class="st">"Q2="</span>,Q2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Is t(x) = Q(x) * Z(x)? True</code></pre>
</div>
<div class="cell-output cell-output-display">
\(\displaystyle \verb|Q=| 304003373219989933642311190906351042896505061116889365884697280369108451328 x^{5} + 18240202393199396018538671454381062573790303667013361953081836822146507079681 x^{4} + 15504172034219486615757870736223903187721758116961357660119561298824531017728 x^{3} + 12160134928799597345692447636254041715860202444675574635387891214764338053122 x^{2} + 7296080957279758407415468581752425029516121466805344781232734728858602831871 x + 7296080957279758407415468581752425029516121466805344781232734728858602831873\)
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Is f1(x) = Q1(x) * Z1(x)? True</code></pre>
</div>
<div class="cell-output cell-output-display">
\(\displaystyle \verb|Q1=| 7296080957279758407415468581752425029516121466805344781232734728858602831873 x + 10944121435919637611123202872628637544274182200208017171849102093287904247807\)
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Is f2(x) = Q2(x) * Z1(x)? True</code></pre>
</div>
<div class="cell-output cell-output-display">
\(\displaystyle \verb|Q2=| 21888242871839275222246405745257275088548364400416034343698204186575808495616 x + 3\)
</div>
</div>
<section id="recap-and-first-protocol" class="level4">
<h4 class="anchored" data-anchor-id="recap-and-first-protocol">Recap and First Protocol</h4>
<p>We now have the tools to define a <strong>preliminary</strong> validation protocol for computing the squared 4th Fibonacci number. Here’s an outline of each party’s steps:</p>
<section id="setup" class="level5">
<h5 class="anchored" data-anchor-id="setup">1. Setup</h5>
<ol type="1">
<li><em>(Both)</em> Fix a working field <span class="math inline">\(\mathbb{F}_p\)</span> and note that we will interpolate polynomials of degree <span class="math inline">\(\le 3\)</span>.</li>
<li><em>(Both)</em> Compute selector polynomials <span class="math inline">\(qL,qR,qM\)</span> corresponding to this circuit.</li>
</ol>
</section>
<section id="prover-computation" class="level5">
<h5 class="anchored" data-anchor-id="prover-computation">2. Prover Computation</h5>
<ol type="1">
<li><p><em>(Prover <span class="math inline">\(P\)</span>)</em> Computes the 4th Fibonacci number squared <span class="math inline">\(F_4^2\)</span> by forming a table of intermediate values, then interpolates them as <strong>3th-degree polynomials</strong>: <span class="math display">\[
a(x), \quad b(x), \quad c(x).
\]</span></p>
<p>as well as selectors <span class="math inline">\(qL(x), \quad qR(x), \quad qM(x)\)</span>.</p></li>
<li><p><em>(Prover <span class="math inline">\(P\)</span>)</em> Computes <span class="math display">\[
t(x)= qL(x) \cdot a(x) + qR(x) \cdot b(x) + qM(x) \cdot (a(x) \cdot b(x)) - c(x)
\]</span> as well as the <strong>quotient polynomial</strong> <span class="math inline">\(Q(x)\)</span> satisfying <span class="math display">\[
t(x) \;=\; Q(x)\,\cdot Z(x).
\]</span></p></li>
<li><p><em>(Prover <span class="math inline">\(P\)</span>)</em> Similarly constructs <span class="math display">\[
f_1(x) \;=\; a(x+1) \;-\; b(x),
\quad
f_2(x) \;=\; b(x+1) \;-\; c(x),
\]</span> along with their quotient polynomials <span class="math display">\[
Q_1(x), \quad Q_2(x)
\]</span> using <span class="math inline">\(Z_1(x)\)</span> for the domain <span class="math inline">\(\{1,2\}\)</span>.</p></li>
</ol>
</section>
<section id="prover-verifier-communication" class="level5">
<h5 class="anchored" data-anchor-id="prover-verifier-communication">3. Prover → Verifier Communication</h5>
<ol type="1">
<li><em>(Prover <span class="math inline">\(P\)</span>)</em> Sends the polynomials <span class="math display">\[
a(x), \; b(x), \; c(x), \; Q(x), \; Q_1(x), \; Q_2(x)
\]</span> to the Validator <span class="math inline">\(V\)</span>.</li>
</ol>
</section>
<section id="verifier-checks" class="level5">
<h5 class="anchored" data-anchor-id="verifier-checks">4. Verifier Checks</h5>
<ol type="1">
<li><p><em>(Verifier <span class="math inline">\(V\)</span>)</em> Checks the base conditions: <span class="math display">\[
a(1) \;=\; 0,
\quad
b(1) \;=\; 1.
\]</span></p></li>
<li><p><em>(Verifier <span class="math inline">\(V\)</span>)</em> Computes <span class="math inline">\(t(x) = qL(x) \cdot a(x) + qR(x) \cdot b(x) + qM(x) \cdot (a(x) \cdot b(x)) - c(x)\)</span> and verifies <span class="math display">\[
t(x) \;=\; Q(x)\,\cdot Z(x).
\]</span> That is, <span class="math inline">\(t(x)\)</span> is indeed divisible by <span class="math inline">\(Z(x)\)</span>.</p></li>
<li><p><em>(Verifier <span class="math inline">\(V\)</span>)</em> Checks the recursive constraints: <span class="math display">\[
f_1(x) \;=\; Q_1(x)\,\cdot Z_1(x),
\quad
f_2(x) \;=\; Q_2(x)\,\cdot Z_1(x).
\]</span></p></li>
<li><p><em>(Verifier <span class="math inline">\(V\)</span>)</em> Checks the square gate constraints: <span class="math display">\[
f_3(4) \;=\; c(3)-b(4)=0 ,
\quad
f_4(4) \;=\; a(4)-b(4)= 0.
\]</span></p></li>
<li><p><em>(Verifier <span class="math inline">\(V\)</span>)</em> If all checks pass, the Verifier concludes <span class="math display">\[
c(4) \; \text{is the correct value of } F_4^2.
\]</span></p></li>
</ol>
<center>
<img src="img_td/first_protocol_s.png" width="500">
</center>
<p>This protocol is correct but seems quite inefficient: instead of doing only 3 additions and one multiplication, we end up performing polynomial multiplications of polynomials of degree 3 over a very large prime field <span class="math inline">\(\mathbb{F}_p\)</span>. We will now consider a more efficient version.</p>
</section>
</section>
</section>
</section>
<section id="towards-a-more-efficient-version" class="level2">
<h2 class="anchored" data-anchor-id="towards-a-more-efficient-version">3.Towards a more efficient version</h2>
<p>We have considered two ways in which the validator <span class="math inline">\(V\)</span> can check whether zero-equality constraints are met: either evaluating the constraint for reach gate of the circuit (i.e.&nbsp;evaluating the polynomial <span class="math inline">\(t(x)\)</span> encoding the sum constraint on each index), or computing the polynomial multiplication between the quotient polynomial <span class="math inline">\(Q(x)\)</span> and the vanishing polynomial <span class="math inline">\(Z(x)\)</span> and check equality against the polynomial encoding the constraints (i.e.&nbsp;<span class="math inline">\(t(x)=Q(x) \cdot Z(x)\)</span>). Among the reasons why the second alternative is advantageous is that we can perform the equality check very efficient with a probabilistic algorithm at the price of (very rarely) making some mistakes.</p>
<p>Consider the following algorithm:</p>
<ul>
<li>The validator has <span class="math inline">\(t(x)\)</span>, <span class="math inline">\(Q(x)\)</span> and <span class="math inline">\(Z(x)\)</span> and wants to know whether <span class="math inline">\(t(x) = Q(x) \cdot Z(x)\)</span>.</li>
<li>They sample a random value <span class="math inline">\(\gamma \in \mathbb{F}_p\)</span>.</li>
<li>They check whether <span class="math inline">\(t(\gamma) = Q(\gamma) \cdot Z(\gamma)\)</span>.</li>
</ul>
<p>Why does this work? Certainly this check is a <em>necessary</em> condition, that is, if the polynomial equality holds, then it also holds when evaluated on a single point. But is it sufficient? In other words, can it be that <span class="math inline">\(t(\gamma) = Q(\gamma) \cdot Z(\gamma)\)</span> holds but <span class="math inline">\(t(x) \neq Q(x) \cdot Z(x)\)</span>? It turns out that yes, that can unfortunately happen, but we can count on how many points this may at most happen, and therefore compute a probability for that event which allows us to reason on how “risky” our protocol is.</p>
<p><strong>Counting errors</strong> Consider two polynomials <span class="math inline">\(f(x), g(x) \in \mathbb{F}_p[x]\)</span> of degree at most <span class="math inline">\(d\)</span>, such that <span class="math inline">\(f(x) \neq g(x)\)</span>. Consider the set of points <span class="math inline">\(S \subseteq \mathbb{F}_p\)</span> such that <span class="math inline">\(\forall s \in S: f(s) = g(s)\)</span>. This set of points <span class="math inline">\(S\)</span> is exactly the set of points for which <span class="math inline">\(f(x) - g(x)=0\)</span>. By assumption <span class="math inline">\(f(x) \neq g(x)\)</span> so <span class="math inline">\(h(x) = f(x)-g(x) \in \mathbb{F}_p[x]\)</span> is a non trivial polynomial of degree at most <span class="math inline">\(d\)</span>. This polynomial <span class="math inline">\(h(x)\)</span> has at most <span class="math inline">\(d\)</span> roots, so the size of <span class="math inline">\(S\)</span> is bounded <span class="math inline">\(|S| \leq d\)</span>. Given that we are sampling a value <span class="math inline">\(\gamma\)</span> uniformly at random from <span class="math inline">\(\mathbb{F}_p\)</span>, the probability of selecting a point in <span class="math inline">\(S\)</span>, in case <span class="math inline">\(f(x) \neq g(x)\)</span>, is <span class="math inline">\(\frac{|S|}{p} \leq \frac{d}{p}\)</span>. This is known as the <a href="https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma">Schwartz-Zippel Lemma</a> (which is more generally stated in a multi-variate polynomial setting).</p>
<p>In our circuit example, given that the polynomials involved are of degree 3, we get an extremely low probability of an incorrect equality check of at most <span class="math inline">\(\frac{3}{p} \approx \frac{1}{2^{252}}\)</span>.</p>
<p><strong>Exercise 3</strong> Compute the equality checks for the gate and recursive constraints with the following random values: <span class="math inline">\(\gamma_1 = 42\)</span>, <span class="math inline">\(\gamma_2 = 74102\)</span> and <span class="math inline">\(\gamma_3 = 987654321987654321\)</span>. You should obtain:</p>
<p><span class="math display">\[\begin{aligned}
t(\gamma_1)
  &amp;= Q(\gamma_1) \cdot Z(\gamma_1)
   = 21888242871839275222246405745257275088548364400416034343698204183303103172977\\
f_1(\gamma_2)
  &amp;= Q_1(\gamma_2) \cdot Z_1(\gamma_2)
   = 271248759392650\\
f_2(\gamma_3)
  &amp;= Q_2(\gamma_3)\cdot Z_1(\gamma_3)
   = 21888242871839275222245442326925691337956137906799110242993653357780575606177
\end{aligned}\]</span></p>
<div id="761ed9a8-1d75-4917-baaa-e425e41a4300" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>γ<span class="dv">1</span> <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>γ<span class="dv">2</span> <span class="op">=</span> <span class="dv">74102</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>γ<span class="dv">3</span> <span class="op">=</span> <span class="dv">987654321987654321</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="second-protocol-version-succinct-probabilistic-check" class="level4">
<h4 class="anchored" data-anchor-id="second-protocol-version-succinct-probabilistic-check">Second Protocol Version (Succinct, Probabilistic Check)</h4>
<p>This improved protocol builds on our earlier version by using: 1. Random challenges sampled by the validator <span class="math inline">\(\gamma_1, \gamma_2, \gamma_3\)</span>, 2. Single-point polynomial evaluations to check $ t(_1) = Q(_1),Z(_1), f_1(_2) = Q_1(_2),Z_1(_2), f_2(_3) = Q_2(_3),Z_1(_3) $.</p>
<p>This lowers the verification cost from a full polynomial multiplication (<span class="math inline">\(O(d^2)\)</span>) to an <span class="math inline">\(O(d)\)</span> evaluation, making verification more succinct.</p>
</section>
<section id="protocol-flow" class="level4">
<h4 class="anchored" data-anchor-id="protocol-flow">Protocol Flow</h4>
<ol type="1">
<li><strong>Compute Fibonacci &amp; Circuit Polynomials</strong>
<ul>
<li><em>(Prover)</em> Generates <span class="math inline">\(F_4^2\)</span> by building the full circuit table.</li>
<li><em>(Prover)</em> Encodes the circuit columns as polynomials <span class="math inline">\(a(x), b(x), c(x)\)</span>.</li>
</ul></li>
<li><strong>Compute Constraint Polynomials</strong>
<ul>
<li><em>(Prover)</em> Defines <span class="math inline">\(t(x)= qL(x) \cdot a(x) + qR(x) \cdot b(x) + qM(x) \cdot (a(x) \cdot b(x)) - c(x)\)</span> and finds <span class="math inline">\(Q(x)\)</span> such that <span class="math inline">\(t(x) = Q(x) \cdot Z(x)\)</span>.</li>
<li><em>(Prover)</em> Similarly, for the recursive constraints: <span class="math inline">\(f_1(x) = a(x+1) - b(x),\)</span> <span class="math inline">\(f_2(x) = b(x+1) - c(x),\)</span> with quotient polynomials $ Q_1(x), Q_2(x) $ satisfying <span class="math inline">\(f_1(x) = Q_1(x)\cdot Z_1(x)\)</span> and <span class="math inline">\(f_2(x) = Q_2(x)\cdot Z_1(x)\)</span>.</li>
</ul></li>
<li><strong>Send Polynomials</strong>
<ul>
<li><em>(Prover)</em> Sends <span class="math inline">\(a(x), b(x), c(x), Q(x), Q_1(x), Q_2(x)\)</span> to the validator.</li>
</ul></li>
<li><strong>Verification (Random Challenge &amp; Single-Point Check)</strong>
<ul>
<li><p><em>(Validator)</em> Samples random values <span class="math inline">\(\gamma_1, \gamma_2, \gamma_3 \in \mathbb{F}_p\)</span>.</p></li>
<li><p><em>(Valdiator)</em> Computes on its own: <span class="math inline">\(t(\gamma_1), \quad f_1(\gamma_2), \quad f_2(\gamma_3)\)</span></p></li>
<li><p><em>(Validator)</em> Checks: <span class="math display">\[
t(\gamma_1) \stackrel{?}{=} Q(\gamma_1)\,Z(\gamma_1), \quad
f_1(\gamma_2) \stackrel{?}{=} Q_1(\gamma_2)\,Z_1(\gamma_2), \quad
f_2(\gamma_3) \stackrel{?}{=} Q_2(\gamma_3)\,Z_1(\gamma_3).
\]</span></p></li>
<li><p>By the <strong>Schwartz–Zippel Lemma</strong>, if <span class="math inline">\(t(x) \neq Q(x)\,Z(x)\)</span> (etc.) the probability it also coincides at a random <span class="math inline">\(\gamma\)</span> is at most <span class="math inline">\(\frac{d}{p}\)</span>.</p></li>
</ul></li>
<li><strong>Accept or Reject</strong>
<ul>
<li><em>(Validator)</em> If all checks pass, the proof is accepted; otherwise, it is rejected.</li>
</ul></li>
</ol>
</section>
<section id="diagram-of-protocol" class="level4">
<h4 class="anchored" data-anchor-id="diagram-of-protocol">Diagram of Protocol</h4>
<p>Below is a simplified diagram illustrating these steps:</p>
<center>
<img src="img_td/succint1_s.png" alt="Succinct Protocol Diagram" width="600">
</center>
<p>With this approach, the <strong>validator</strong> does a constant amount of final checks (polynomial evaluations), regardless of the polynomial degree <span class="math inline">\(d\)</span>, achieving <strong>succinct</strong> verification.</p>
</section>
</section>
<section id="an-even-more-efficient-version" class="level2">
<h2 class="anchored" data-anchor-id="an-even-more-efficient-version">4.An even more efficient version</h2>
<p>To put things into perspective, our latest protocol version requires sharing 6 polynomials of degree at most <span class="math inline">\(d=3\)</span> (quotients are typically shorter), and the validator has to still do at most 3 multiplications per each one of the 3 equality checks. That is a communication cost of about <span class="math inline">\(3*6\)</span> field elements and <span class="math inline">\(3*3\)</span> field element multiplications. In general this would be ca. <span class="math inline">\(d*6\)</span> field elements in communication and <span class="math inline">\(3*d\)</span> field multiplications for the <span class="math inline">\(d\)</span>-th Fibonacci number (rounding this to the number of padded rows as discussed before). This does not seem quite useful given that only about <span class="math inline">\(d\)</span> additions would allows us to compute the <span class="math inline">\(d\)</span>-th Fibonacci number directly!</p>
<p>But there is a goal behind our strategy. Our goal is to make both the communication and the verification constant (<span class="math inline">\(O(1)\)</span>) for circuits with many gates! To achieve this we need a very useful primitive called a Polynomial Commitment Scheme. In particular, we are going to use the method called KZG. This method relies on pairings over elliptic curves and to keep this notebook as lean as possible, we are preparing a separate tutorial on this topic.</p>
<p>In the following we simply recap some fundamental properties of the needed ingredients while keeping our goal on sight.</p>
<p><strong>What do we want to achieve?</strong> In a nutshell what we want to achieve is the following: We want to completely delegate computation of the circuit to the processor, and as before, also the interpolation of the column polynomial and the computation of the quotients. But the twist is, we will not ask for a full copy of a given polynomial <span class="math inline">\(f(x)\)</span>, but just a very short and constant size piece of information that we call a <strong>commitment</strong> <span class="math inline">\(c_f=\textsf{commitment}(f(x))\)</span>. With this commitment, we can at a later stage challenge the validator to evaluate <span class="math inline">\(f(\gamma)=\alpha\)</span>. We will be able to check on our whether indeed <span class="math inline">\(f(\gamma) = \alpha\)</span> by using <span class="math inline">\(\gamma, \alpha\)</span> and the commitment <span class="math inline">\(c_f\)</span> using a function <span class="math inline">\(\textsf{verify}(\alpha,\gamma,c_f)\)</span>.</p>
<p>What this accomplishes:</p>
<ul>
<li>Instead of sharing a <span class="math inline">\(d\)</span>-size vector for each polynomial over the network, we only share two elements: <span class="math inline">\(c_f \in E\)</span>, where <span class="math inline">\(E\)</span> is an elliptic curve, and <span class="math inline">\(\alpha \in \mathbb{F}_p\)</span>.</li>
<li>A malicious or misbehaving processor <span class="math inline">\(P\)</span> cannot adapt to the interactive challenge <span class="math inline">\(\gamma\)</span> since it has already commited to a polynomial before seeing the challenge. This gives the validator confidence that the value was correctly computed.</li>
<li>We can directly perform the constraint checks <span class="math inline">\(f(\gamma)=Q(\gamma) \cdot Z(\gamma)\)</span> in constant time, regardless of the number of gates in the circuit (that is, the polynomial <span class="math inline">\(d\)</span> of the interpolating polynomial). Certainly there are some upper bounds to the size of a circuit and we will come back to this later.</li>
</ul>
<p>Given that by making this protocol more efficient we have to make it more resilient to misbehaving processors, we are going to call <span class="math inline">\(P\)</span> a <em>prover</em> and <span class="math inline">\(V\)</span> a <em>verifier</em> from now on.</p>
<section id="pairings" class="level4">
<h4 class="anchored" data-anchor-id="pairings">Pairings</h4>
<p>The first ingredient for our new protocol version will be a suitable elliptic curve pairing. We will give you some precomputed functions, but you may reconstruct them on your own.</p>
<p>We need a mapping:</p>
<p><span class="math display">\[e: \mathbb{G_1} \times \mathbb{G_2} \to \mathbb{G_t}\]</span></p>
<p>for additive cyclic groups <span class="math inline">\((\mathbb{G_1},+)\)</span> and <span class="math inline">\((\mathbb{G_2},+)\)</span> and multiplicative <span class="math inline">\((\mathbb{G_t},*)\)</span>. Note that typically the first two groups are additive (since they are subgroups of an elliptic curve) and the destination group is multiplicative (usually defined over a field).</p>
<p>The mapping <span class="math inline">\(e\)</span> we are looking for is “bilinear”, that means:</p>
<p><span class="math display">\[e(P + P', Q) = e(P,Q)*e(P',Q)\]</span> <span class="math display">\[e(P,Q+Q')=e(P,Q)*e(P,Q')\]</span></p>
<p>To construct <strong>secure</strong> pairings, it is important to chose the groups in a particular way which motivates choosing isomorphic but disjoint <span class="math inline">\(\mathbb{G_1},\mathbb{G_2}\)</span> which can be found as subgroups of an elliptic curve over a finite field extension <span class="math inline">\(E(\mathbb{F}_{q^k})\)</span> and <span class="math inline">\(\mathbb{G_t}\)</span> a subgroup of <span class="math inline">\(\mathbb{F^*}_{q^k}\)</span>. We are not going to explain this in more depth but if you are curious check <a href="https://static1.squarespace.com/static/5fdbb09f31d71c1227082339/t/5ff394720493bd28278889c6/1609798774687/PairingsForBeginners.pdf">Pairings for Beginners by Craig Costello</a>.</p>
<div id="d56dfb6f-8ea9-404a-8423-9bd24747eede" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> kzg</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> e(P,Q):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Base field for BN254</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> <span class="dv">21888242871839275222246405745257275088696311157297823662689037894645226208583</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Number of points on BN254</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> Integer(<span class="dv">21888242871839275222246405745257275088548364400416034343698204186575808495617</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="dv">12</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="dv">6</span><span class="op">*</span><span class="bu">pow</span>(<span class="dv">4965661367192848881</span>,<span class="dv">2</span>)<span class="op">+</span><span class="dv">1</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P.ate_pairing(Q, n, k, t,q)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="598ab309-c1b1-424c-9c3a-9f95db60c03b" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> kzg.P</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> kzg.Q</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>show(<span class="st">"P:"</span>,P)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>show(<span class="st">"Q:"</span>,Q)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>show(e(P,Q))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
\(\displaystyle \verb|P:| \left(1 : 2 : 1\right)\)
</div>
<div class="cell-output cell-output-display">
\(\displaystyle \verb|Q:| \left(\left(11559732032986387107991004021392285783925812861821192530917403151452391805634 ubar + 10857046999023057135944570762232829481370756359578518086990519993285655852781\right) wbar^{2} : \left(4082367875863433681332203403145435568316851327593401208105741076214120093531 ubar + 8495653923123431417604973247489272438418190587263600148770280649306958101930\right) wbar^{3} : 1\right)\)
</div>
<div class="cell-output cell-output-display">
\(\displaystyle \left(15485169958187804055419367470727586316504614054038886924834910714644298081076 ubar + 14110042394329134992063060126132667374513734777529849604059403292605387766763\right) wbar^{5} + \left(17576687079377474679994084448626848766364851367692113922904391421785791556046 ubar + 15263055409656443157285976462204135910932331054849227253916602565546649989931\right) wbar^{4} + \left(1451055192040231810539564576166577843622781952620338854414099592814058446945 ubar + 19362144781956138062795090409372908218130916662778620452325203445403259212772\right) wbar^{3} + \left(7786695150901409298856750468044088494675441502192568573069643047819302766865 ubar + 16893543948180465298099197784510869270928575391710795413610320310782594693022\right) wbar^{2} + \left(8339301614695659949019663159218383351646785965635781625471751346963751888108 ubar + 465898347631256865746797445390333094396673986355153352843254722736295902148\right) wbar + 15780004297944302906621723394852439600559246581555156000423333429824441348714 ubar + 17296046054077859324401147072502722261136321305912126349272372680482680769943\)
</div>
</div>
<p><strong>Exercise 4</strong> Check that the provided <span class="math inline">\(e\)</span> function is bilinear by randomly sampling an integer <span class="math inline">\(s\)</span> and multiplying over the additive subgroups:</p>
<p><span class="math display">\[ e([s]\cdot P,Q)=e(P,[s] \cdot Q)=e(P,Q)^s\]</span></p>
<div id="27a54bc0-cae5-409e-a116-e7f419da23dd" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="70">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>s<span class="op">=</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="kzg-commitment" class="level4">
<h4 class="anchored" data-anchor-id="kzg-commitment">KZG commitment</h4>
<p>Our goal is to leverage pairings to help provers to <em>commit</em> to a polynomial <span class="math inline">\(f(x)\)</span> before receiving the challenge <span class="math inline">\(\gamma\)</span> and for the verifier to have (cryptographic) certainty that the evaluation <span class="math inline">\(f(\gamma)\)</span> was done on this same commited polynomial, ruling out adaptive attacks. There are several answers in the literature to solve this exact problem, one prominent one is the <a href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf">KZG commitment scheme</a>. We can illustrate the protocol with the following sequence diagram.</p>
<center>
<img src="img_td/kzg.png" width="300">
<figcaption>
<b>Figure 3</b>: The KZG commitment scheme.
</figcaption>
</center>
<p><br></p>
<p><strong>Exercise 5</strong> For this protocol to work, we need a trusted setup based on a uniformly random (and secret) <em>toxic waste</em> τ. This is called toxic waste since it must be deleted after some setup values have been computed with it in order for the protocol to be secure. We also need to declare a public maximum polynomial degree <span class="math inline">\(l\)</span>. Since we will later commit to multiplication of low degree polynomials, let us pick <span class="math inline">\(l=10\)</span>.</p>
<p>With example <span class="math inline">\(\tau=424242\)</span>, compute two public parameters: a vector <span class="math display">\[S_1 = [  P, \tau \cdot P , \tau^2 \cdot P , \cdots,  \tau^{l} \cdot P]\]</span></p>
<p>where <span class="math inline">\(P\)</span> is the generator of <span class="math inline">\(\mathbb{G}_1\)</span> and a value <span class="math display">\[S_2 = \tau \cdot Q\]</span> where <span class="math inline">\(Q\)</span> is the generator of the group <span class="math inline">\(\mathbb{G}_2\)</span>.</p>
<div id="f5e7325f" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>τ <span class="op">=</span> <span class="dv">424242</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>l<span class="op">=</span><span class="dv">10</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>S1<span class="op">=</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>S2<span class="op">=</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If computed correctly you should get:</p>
<p><span class="math inline">\(S1 =\left[\left(1 : 2 : 1\right), \left(3388106087484702502772161951837520865682365219266094058038991331506090320735 : 10310862820936104897688292475187545406556140958479334534497508049176340462168 : 1\right), \left(5786299459695789788261684662131390109566181344091061986154006773045920884529 : 18198083969462810098554436542449595852850793038741994323649111219383738839374 : 1\right), \left(5932386722799341949736906223819928737327798404444018663115122905353930163217 : 17316789122660091087982740003020863959605853926224865905583913597777031548221 : 1\right), \left(14603143723753528702641274659350642057392810682423113693594196367092666272615 : 17734357240639322091230265203514580412414342326449923671483947891721675198742 : 1\right), \left(1485870938289488242176031429247482114928668541241910486620153058173498550422 : 8975504733770431670587733015492501696212039808343155103983507429794936273090 : 1\right), \left(35087711382470900519387874116184362249603265567233267930080986182721755391 : 9687295787051875541592859447450503637855174457649076441192556983747473888473 : 1\right), \left(21100087779353388367643433264506322944085867030119306347233967681812330825611 : 17068231115940713163151138839050846284784298672314356795840059410045954257490 : 1\right), \left(10641104735982477671491147382199353108251699282959504595440637553392719424596 : 3033897669229592557681916129851961240665115699542840722127903032620063452401 : 1\right), \left(12461517031230393262909098092888598630825065680164551109453025306556394017248 : 11406184524960241674372900569663181593279300027508257400554857135388045542548 : 1\right), \left(2310703006113265329769149621286389443406062880925858119855767049953176497692 : 20254007398902051444166009223523085479917136359422165955249757385592434525697 : 1\right)\right]\)</span></p>
<p>and:</p>
<p><span class="math inline">\(S2 = \left(\left(18178798121214140434976027337622332703345638858169149597321922257824015358086 ubar + 17892288729126503148648989889095246645011224085306750203724686651395006961383\right) wbar^{2} : \left(15251007341879318938631029793693405432107362852215428951388705343135014132495 ubar + 11565079700697045165214936027269859661189920603201791930010463312628382919842\right) wbar^{3} : 1\right)\)</span></p>
<center>
<img src="img_td/sendcommitment.png" width="300">
</center>
<p><br></p>
<p><strong>Exercise 6</strong> Implement a <em>commitment</em> function. This function takes as parameters the public vector <span class="math inline">\(S_1\)</span> we computed before and the polynomial <span class="math inline">\(p(x)\)</span> we want to commit to. It then computes <span class="math display">\[\sum_{i=0}^{l} a_i \cdot S_1[i] \]</span></p>
<p>Note that by construction this is:</p>
<p><span class="math display">\[a_0 \cdot P + a_1 \cdot \tau \cdot P + a_2 \cdot \tau^2 \cdot P  + \cdots + a_{l} \cdot \tau^{l} \cdot P \]</span></p>
<p>which is equivalent to:</p>
<p><span class="math display">\[p(\tau) \cdot P\]</span></p>
<p>Note that this will be a point on the curve <span class="math inline">\(EK\)</span>. Test your function over the polynomial <span class="math inline">\(a(x)\)</span> of the Fibonacci example.</p>
<div id="b302ee82" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> commitment(S1,p):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Solve here!</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If computed correctly, you should get a commitment:</p>
<p><span class="math display">\[c = \left(19772988533509128204934208855583299243034568734268587639600165428945857082832 : 21198549198844316278609987090510616007059968516882705878791833422348082226388 : 1\right)\]</span></p>
<p>Now this commitment <span class="math inline">\(c\)</span> can be given to the verifier before any challenge is issued.</p>
<center>
<img src="img_td/challengephase.png" width="300">
</center>
<p>In a subsequent step, the prover will receive the challenge <span class="math inline">\(\gamma\)</span> from the verifier. They will now give back <span class="math inline">\(f(\gamma)\)</span> but this time also a proof <span class="math inline">\(\pi\)</span> that indeed this is the evaluation of <span class="math inline">\(\gamma\)</span> in the very same polynomial that the prover commited to through <span class="math inline">\(c\)</span>.</p>
<p><strong>Exercise 7</strong> The <span class="math inline">\(\textsf{proof}\)</span> generating function receives two parameters, the vector <span class="math inline">\(S_1\)</span> and a polynomial <span class="math inline">\(Q_c\)</span>. Similar as before, this will compute a point on the curve which is equal to:</p>
<p><span class="math display">\[\pi = b_0 \cdot P + b_1 \cdot \tau \cdot P + b_2 \cdot \tau^2 \cdot P + \cdots + b_{l} \cdot \tau^{l} \cdot P = Q_c(\tau) \cdot P\]</span></p>
<p>where <span class="math inline">\(b_i\)</span> are the coefficients of the polynomial <span class="math inline">\(Q_c\)</span>. Now, the way this polynomial is constructed is essential for the proof:</p>
<p><span class="math display">\[Q_c(x) = \frac{f(x) - f(\gamma)}{x-\gamma} \]</span></p>
<p>Again here we are exploiting the fact that <span class="math inline">\(\gamma\)</span> is a root of <span class="math inline">\(f(x) - f(\gamma)\)</span> therefore this polynomial must be divisible by <span class="math inline">\(x-\gamma\)</span>. Compute the <span class="math inline">\(\texttt{proof}\)</span> function and test it on the <span class="math inline">\(Q_c\)</span> polynomial for the challenge <span class="math inline">\(\gamma = 151515\)</span> and the polynomial <span class="math inline">\(a(x)\)</span>.</p>
<div id="0625803d" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> proof(S1,Qc):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Solve here!</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">#Given a challenge γ</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>γ <span class="op">=</span> <span class="dv">151515</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>Qc<span class="op">=</span> </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>π <span class="op">=</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If computed correctly, the proof obtained from <span class="math inline">\(\texttt{proof}\)</span> when called on <span class="math inline">\(Q_c\)</span> should be:</p>
<p><span class="math display">\[\pi = \left(18427764633036746853571353448280965399000717707037995558464363091930831203059 : 15823869948268955546174436172082876809321127559750802916163692992123652869945 : 1\right)\]</span></p>
<p>The value of the polynomial on the challenge point is:</p>
<p><span class="math display">\[a(\gamma) = 1739069066686765\]</span></p>
<center>
<img src="img_td/verificationphase.png" width="300">
</center>
<p>So now the prover, who has issued the challenge <span class="math inline">\(\gamma\)</span>, has both <span class="math inline">\(c\)</span> and <span class="math inline">\(\pi\)</span>. He will use the verification function that takes as parameters <span class="math inline">\(c, \pi, \gamma\)</span> and <span class="math inline">\(b=f(\gamma)\)</span>. We are finally ready to use the pairing. We want to check whether the following values are equal.</p>
<p><span class="math display">\[
{e(\pi, S_2 - \gamma \cdot Q)} \stackrel{?}{=} {e(c- b \cdot P, Q)}
\]</span></p>
<p>The <strong>left-hand side</strong> is:</p>
<p><span class="math display">\[
{e(\pi, S_2 - \gamma \cdot Q)} = e( Q_c(\tau) \cdot P, (\tau - \gamma) \cdot Q)
\]</span></p>
<p>and using bilinearity:</p>
<p><span class="math display">\[
e( Q_c(\tau) \cdot P, (\tau - \gamma) \cdot Q) = e( {Q_c(\tau)\cdot (\tau - \gamma)} \cdot P,  Q)
\]</span></p>
<p>The <strong>right-hand side</strong> is:</p>
<p><span class="math display">\[
{e(c- b \cdot P, Q)} = e(f(\tau) \cdot P - f(\gamma) \cdot P, Q) = e( {(f(\tau) - f(\gamma))} \cdot P, Q)
\]</span></p>
<p>So essentially what the pairing allows us to do is to check:</p>
<p><span class="math display">\[
{f(\tau) - f(\gamma)} \stackrel{?}{=} {Q_c(\tau)\cdot (\tau - \gamma)}
\]</span></p>
<p>which is expected by the construction of <span class="math inline">\(Q_c\)</span>. This is equivalent to checking polynomial equality using the challenge <span class="math inline">\(\tau\)</span>. But remember, nobody knows <span class="math inline">\(\tau\)</span> directly because we deleted it after setup (“toxic waste”)!</p>
<p><strong>Exercise 8</strong> Implement a <span class="math inline">\(\textsf{verification}\)</span> function that takes <span class="math inline">\(c,\pi,\gamma\)</span> and <span class="math inline">\(f(\gamma)=b\)</span> as parameters. It should output true or false, by evaluating:</p>
<p><span class="math display">\[{e(\pi, S_2 - \gamma \cdot Q)} \stackrel{?}{=} {e(c- b \cdot P, Q)}
\]</span></p>
<p>Test the function on the previously computed commitment <span class="math inline">\(c\)</span> for <span class="math inline">\(a(x)\)</span> and the proof <span class="math inline">\(\pi\)</span> computed in the previous exercise.</p>
<div id="750d33ae" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> verification(c,π,γ,b):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Solve here!</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(verification(c,π,γ,b)) <span class="co">#should return True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="new-protocol-version" class="level4">
<h4 class="anchored" data-anchor-id="new-protocol-version">New Protocol Version</h4>
<p>We divide the protocol into <strong>Setup</strong>, <strong>Prover Computation</strong>, <strong>Verifier Challenge</strong>, and <strong>Proof &amp; Verification</strong> phases.</p>
</section>
<section id="setup-phase" class="level4">
<h4 class="anchored" data-anchor-id="setup-phase">1. Setup Phase</h4>
<ol type="1">
<li><em>(Both)</em> Agree on the public parameters <span class="math inline">\((S_1, S_2)\)</span>.</li>
<li><em>(Verifier)</em> Publicly specifies the maximum polynomial degree <span class="math inline">\(d\)</span>, if needed.</li>
<li><em>(Trusted Ceremony / Setup)</em> Generates a secret <span class="math inline">\(\tau\)</span> and produces <span class="math inline">\((S_1, S_2)\)</span>.<br>
After this step, <span class="math inline">\(\tau\)</span> (the toxic waste) must be discarded to maintain security.</li>
</ol>
</section>
<section id="prover-computation-phase" class="level4">
<h4 class="anchored" data-anchor-id="prover-computation-phase">2. Prover Computation Phase</h4>
<ol type="1">
<li><em>(Prover)</em> Interpolates the column polynomials <span class="math inline">\(a(x), b(x), c(x)\)</span>.</li>
<li><em>(Prover)</em> Constructs quotient polynomials <span class="math inline">\(Q(x), Q_1(x), Q_2(x)\)</span> with respect to the vanishing polynomials <span class="math inline">\(Z(x), Z_1(x)\)</span>.</li>
<li><em>(Prover)</em> Commits to each polynomial by computing <span class="math display">\[
c_a = \text{commit}(a), \quad
c_b = \text{commit}(b), \quad
c_c = \text{commit}(c), \quad
c_Q = \text{commit}(Q), \quad \dots
\]</span> and sends these commitments to the Verifier.</li>
</ol>
</section>
<section id="verifier-challenge-phase" class="level4">
<h4 class="anchored" data-anchor-id="verifier-challenge-phase">3. Verifier Challenge Phase</h4>
<ol type="1">
<li><em>(Verifier)</em> Samples random challenges <span class="math inline">\(\gamma_1, \gamma_2, \gamma_3\)</span>.</li>
<li><em>(Verifier)</em> Sends the challenges to the Prover.</li>
</ol>
</section>
<section id="proof-verification-phase" class="level4">
<h4 class="anchored" data-anchor-id="proof-verification-phase">4. Proof &amp; Verification Phase</h4>
<ol type="1">
<li><p><em>(Prover)</em> Evaluates each committed polynomial at its corresponding challenge. For example, <span class="math display">\[
a(\gamma_1), \quad b(\gamma_1), \quad c(\gamma_1), \quad Q(\gamma_1).
\]</span> Then constructs proofs <span class="math inline">\(\pi_a, \pi_b, \pi_c, \pi_Q\)</span> via the KZG evaluation method. The Prover sends <span class="math display">\[
\bigl(a(\gamma_1),\,b(\gamma_1),\,c(\gamma_1),\,Q(\gamma_1)\bigr)
\]</span> and <span class="math display">\[
(\pi_a,\,\pi_b,\,\pi_c,\,\pi_Q)
\]</span> to the Verifier.</p></li>
<li><p><em>(Verifier)</em> Uses the commitments <span class="math inline">\((c_a,\,c_b,\,c_c,\,c_Q)\)</span> and the proofs <span class="math inline">\(\pi_a, \pi_b, \pi_c, \pi_Q\)</span> to verify each polynomial evaluation.<br>
It then checks the constraint <span class="math display">\[
a(\gamma_1) + b(\gamma_1) - c(\gamma_1)
  \;=\; Q(\gamma_1)\,\cdot Z(\gamma_1).
\]</span> Since the Verifier can construct <span class="math inline">\(Z(x)\)</span> itself, it only needs to check <span class="math inline">\(t(\gamma_1) = Q(\gamma_1)\,Z(\gamma_1)\)</span>, where <span class="math inline">\(t(x)= qL(x) \cdot a(x) + qR(x) \cdot b(x) + qM(x) \cdot (a(x) \cdot b(x)) - c(x)\)</span>.</p></li>
<li><p><em>(Verifier)</em> Repeats a similar check for the recursive constraints: <span class="math display">\[
a(\gamma_2 + 1) \;-\; b(\gamma_2) \;=\; Q_1(\gamma_2)\,\cdot Z_1(\gamma_2),
\]</span> <span class="math display">\[
b(\gamma_3 + 1) \;-\; c(\gamma_3) \;=\; Q_2(\gamma_3)\,\cdot Z_1(\gamma_3).
\]</span></p></li>
<li><p><em>(Verifier)</em> If all these checks pass, the Verifier accepts. Otherwise, it rejects.</p></li>
</ol>
<p>As you can see, both the number of message exchanges and the operations performed by the Verifier are now almost constant. In other words, the Verifier can ask the Prover to compute <span class="math inline">\(F_6\)</span> or <span class="math inline">\(F_{1000}\)</span> and still carry out about the same number of computations. The only operation dependent on the number of rows of the circuit on the verifier’s side is the computation of the vanishing polynomials <span class="math inline">\(Z\)</span> and <span class="math inline">\(Z_1\)</span>.</p>
</section>
<section id="protocol-diagram" class="level4">
<h4 class="anchored" data-anchor-id="protocol-diagram">Protocol Diagram</h4>
<p>The following diagram visually represents the four main phases of the protocol:</p>
<ol type="1">
<li><strong>Phase 1: Setup</strong>
<ul>
<li>Both parties agree on the public parameters <span class="math inline">\((S_1, S_2)\)</span>.<br>
</li>
<li>The Verifier may specify the maximum polynomial degree <span class="math inline">\(d\)</span>.<br>
</li>
<li>A trusted ceremony generates the secret <span class="math inline">\(\tau\)</span>, then discards it, while producing the public parameters <span class="math inline">\((S_1, S_2)\)</span>.</li>
</ul></li>
<li><strong>Phase 2: Prover Computation</strong>
<ul>
<li>The Prover interpolates the circuit columns (e.g., Fibonacci) into polynomials <span class="math inline">\(a(x), b(x), c(x)\)</span>.<br>
</li>
<li>Constructs the quotient polynomials <span class="math inline">\(Q(x), Q_1(x), Q_2(x)\)</span> relative to vanishing polynomials <span class="math inline">\(Z, Z_1\)</span>.<br>
</li>
<li>Commits to these polynomials (e.g., <span class="math inline">\(c_a, c_b, c_c, c_Q, \dots\)</span>) and sends the commitments to the Verifier.</li>
</ul></li>
<li><strong>Phase 3: Verifier Challenge</strong>
<ul>
<li>The Verifier randomly samples challenges <span class="math inline">\(\gamma_1, \gamma_2, \gamma_3\)</span>.<br>
</li>
<li>Sends these challenges to the Prover.</li>
</ul></li>
<li><strong>Phase 4: Proof &amp; Verification</strong>
<ul>
<li>The Prover evaluates each committed polynomial at the corresponding <span class="math inline">\(\gamma\)</span> value and constructs proofs (e.g., <span class="math inline">\(\pi_a, \pi_b\)</span>).<br>
</li>
<li>Sends the polynomial evaluations and proofs to the Verifier.<br>
</li>
<li>The Verifier checks that the evaluations match the commitments, confirming equations like <span class="math display">\[
t(\gamma_1) \;=\; Q(\gamma_1) \cdot Z(\gamma_1).
\]</span></li>
<li>If all checks pass, the Verifier accepts; otherwise, it rejects.</li>
</ul></li>
</ol>
<center>
<img src="img_td/succint2.png" width="500">
</center>
</section>
</section>
<section id="domains-and-selectors" class="level2">
<h2 class="anchored" data-anchor-id="domains-and-selectors">5.Domains and selectors</h2>
<p>Note that so far we have exploited a convenient structure to verify the correctness of a computation: that of evaluating polynomials on a set of points (or indexes) <span class="math inline">\(I\)</span> and checking constraints by means of quotient polynomials. This way we could almost bring the computational time of the verifier to a constant. But there is a catch: computing the vanishing polynomials <span class="math inline">\(Z\)</span> and <span class="math inline">\(Z_1\)</span> as the multiplication of <span class="math inline">\((x-i)\)</span> monomials, although not a very expensive operation is still dependent on the number of rows of the circuit (which corresponds to the maximum polynomial degree <span class="math inline">\(d\)</span>). Also, the way we check constraints <span class="math inline">\(f_1\)</span> and <span class="math inline">\(f_2\)</span>, by comparing values in a given row with the next row, and by considering a different index set <span class="math inline">\(I' = I \setminus{\{3,4\}}\)</span> is not very general. What if we want to evaluate a circuit where connections between gates are different, do we have to define a new polynomial for each constraint by hand and carefully think about which domain to evaluate?</p>
<p>To address this issues, and to improve efficiency even more, let us introduce a different type of indexing: using a multiplicative subgroup (also referred to commonly as a <em>domain</em>). A particularly interesting set of domains are the ones with size <span class="math inline">\(n=2^k\)</span>. Mathematically we want to find a set of points <span class="math inline">\(\Omega \in \mathbb{F}_p\)</span> such that:</p>
<p><span class="math display">\[\Omega = \{ \omega, \omega^2, \dots, \omega^{2^k-1},1 \}\]</span></p>
<p>for some generator <span class="math inline">\(\omega \in \mathbb{F}_p\)</span>. This set will replace our previous set of indexes <span class="math inline">\(I\)</span>. One immediate advantage of this choice is that computing the vanishing polynomial for the domain can be done in constant time, because <span class="math inline">\(Z = x^n - 1\)</span>, and we no longer need to multiply each monomial <span class="math inline">\((x-i)\)</span> as we did with the additive indexes. This follows immediately from the definition of <span class="math inline">\(\Omega\)</span> given that each element is a so-called “<span class="math inline">\(n\)</span>-root of unity”, a field element of order <span class="math inline">\(n\)</span>: for every <span class="math inline">\(\omega^i \in \Omega\)</span>, it holds <span class="math inline">\((\omega^i)^n = (\omega^n)^i = 1^i = 1\)</span>.</p>
<p><strong>Exercise 9</strong> Find a generator <span class="math inline">\(\omega\)</span> of a domain of order <span class="math inline">\(4\)</span> using the following algorithm. Consider <span class="math inline">\(r = (p-1)/4\)</span>. Find the smallest <span class="math inline">\(h \in \mathbb{F}_p\)</span> such that <span class="math inline">\(\omega=h^r\)</span> has multiplicative order <span class="math inline">\(4\)</span>. In other words, <span class="math inline">\(\omega^4 = 1\)</span> and <span class="math inline">\(\omega^i \neq 1\)</span> for <span class="math inline">\(i \in \{1,2,3,4\}\)</span>.</p>
<div id="4ca804e6-f850-4722-9b0e-107c028512a3" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">pow</span>(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> </span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>ω <span class="op">=</span> </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If computed correctly you should obtain:</p>
<p><span class="math display">\[\omega = 21888242871839275217838484774961031246007050428528088939761107053157389710902
\]</span></p>
<p>Note that a further interesting property of working with multiplicative indexes is that they “wrap around”, that is, whenever we go beyond the order of the multiplicative group, we cycle back to the beginning of the group: <span class="math inline">\(\omega^0 = \omega^n = 1\)</span>. We will benefit from this property in the next section, were we generalize wiring constraints.</p>
<p><strong>Exercise 10</strong> Interpolate the value vectors and selector vectors as before, now over <span class="math inline">\(\Omega\)</span> instead of <span class="math inline">\(I\)</span>.</p>
<div id="0b18e276-77f0-4b69-b0f4-30c115f6539c" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here! Hint: your previously defined interpolate function should also work here!</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>Ω <span class="op">=</span> </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> </span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>qL <span class="op">=</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>qR <span class="op">=</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>qM <span class="op">=</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If computed correctly you should have obtained:</p>
<p><span class="math display">\[a(x)=16416182153879456417786784551517017277046601793284012108757927423286461067892 x^{3} + 5472060717959818805561601436314318772137091100104008585924551046643952123905 x^{2} + 5472060717959818804459621193740257811501762607132022234940276763289347427726 x + 16416182153879456416684804308942956316411273300312025757773653139931856371714
\]</span></p>
<p>We said that one of the advantage of working with multiplicatives domains is that the verifier can now use <span class="math inline">\(Z(x)=x^n-1\)</span> as the vanishing polynomial, which can be computed in constant time, instead of <span class="math inline">\(Z(x)=\prod_i^d (x-i)\)</span> which is an <span class="math inline">\(O(d)\)</span> operation.</p>
<p><strong>Exercise&nbsp;11</strong> Let <span class="math inline">\(t(x) \;=\; qM*a*b + qL*a+qR*b-c\)</span> where the polynomials&nbsp;<span class="math inline">\(a(x),\,b(x),\,c(x)\)</span> are obtained by Lagrange–interpolating the three witness columns over the multiplicative domain <span class="math inline">\(\Omega \;=\; \{\omega,\; \omega^{2}, \dots, \omega^{4}\,\}\)</span>. Take the domain‑vanishing polynomial <span class="math inline">\(Z(x) \;=\; x^{4} - 1\)</span>. Perform polynomial long‑division of&nbsp;<span class="math inline">\(t(x)\)</span> by&nbsp;<span class="math inline">\(Z(x)\)</span>; that is, find polynomials&nbsp;<span class="math inline">\(Q(x),\,R(x) \in \mathbb{F}_{p}[x]\)</span> such that:</p>
<p><span class="math display">\[t(x) = Q(x) \cdot Z(x) + R(x)\]</span></p>
<p>Verify that the division is <em>exact</em>: show that the remainder&nbsp;<span class="math inline">\(R(x)\)</span> is zero. Equivalently, confirm that there exists a polynomial <span class="math inline">\(Q(x) \in \mathbb{F}_{p}[x]\)</span> for which</p>
<p><span class="math display">\[t(x) \;=\; Q(x) \cdot Z(x)\]</span></p>
<div id="14e35025-9193-42c8-9cf3-4abf824dbd88" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span>                      </span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>Quo<span class="op">=</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>Rem<span class="op">=</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Quotient Q(x):</span><span class="ch">\n</span><span class="st">"</span>, Quo)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Remainder R(x):</span><span class="ch">\n</span><span class="st">"</span>, Rem)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Is remainder zero?  "</span>, Rem <span class="op">==</span> <span class="dv">0</span>) <span class="co">#should be True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="copy-constraints" class="level2">
<h2 class="anchored" data-anchor-id="copy-constraints">6.Copy constraints</h2>
<p>Recall our discussion on the recursive constraints <span class="math inline">\(f_1,f_2,f_3\)</span> and <span class="math inline">\(f_4\)</span> for our squared Fibonacci example. What we wanted to achieve essentially was to ensure that some values (input or output) in a previous row were re-used in a subsequent row. This is nothing else than what is commonly known as the “wiring” of a circuit: an input wire may be linked to multiple gates, or the output wire of a gate can be the input of another. Mathematically we can think of wiring as a partition of positions in the table representing the circuit into equivalence classes (defined by equality). Consider the following image. Here we can see the 4 partitions as different colors both on the table and on the circuit.</p>
<center>
<img src="img_td/partitions_s.png" width="400">
</center>
<p><strong>Exercise 12</strong>: Compute an array encoding a permutation over the three columns <span class="math inline">\(a,b,c\)</span>. That is, compute a mapping from <span class="math inline">\(1,2,\cdots, 12\)</span> to <span class="math inline">\(1,2,\cdots, 12\)</span> that encodes the equivalence relation of the wiring between the three columns. For example <span class="math inline">\(2 \to 5\)</span> and <span class="math inline">\(5 \to 2\)</span> because 5 is the first position (<span class="math inline">\((4+1)\)</span>) of the second column.</p>
<div id="08f0f45b-c403-4e40-b3c8-47d25b78ec76" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> {}</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">#First input</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>sigma[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co">#First cycle</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>sigma[<span class="dv">2</span>] <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>sigma[<span class="dv">5</span>] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If implemented correctly, your permutation should pass the following checks.</p>
<div id="a0e425d2-7175-45cd-b849-015cf3b19db0" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="18">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Length should be 12:"</span>, <span class="bu">len</span>(sigma) <span class="op">==</span> <span class="dv">12</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"There should be no repeated elements in the domain:"</span>, <span class="bu">len</span>(<span class="bu">set</span>(sigma.keys())) <span class="op">==</span> <span class="dv">12</span> ) </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Both the image and domain should be the indexes from 1 to 12"</span>, <span class="bu">set</span>(sigma.keys()) <span class="op">==</span> <span class="bu">set</span>(<span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">13</span>)) <span class="op">==</span> <span class="bu">set</span>(sigma.values()))</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The cycle (3,4+2,8+1) should be in sigma:"</span> , sigma[<span class="dv">3</span>] <span class="op">==</span> <span class="dv">4</span><span class="op">+</span><span class="dv">2</span> <span class="kw">and</span> sigma[<span class="dv">4</span><span class="op">+</span><span class="dv">2</span>] <span class="op">==</span> <span class="dv">8</span><span class="op">+</span><span class="dv">1</span> <span class="kw">and</span> sigma[<span class="dv">8</span><span class="op">+</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Length should be 12: True
There should be no repeated elements in the domain: True
Both the image and domain should be the indexes from 1 to 12 True
The cycle (3,4+2,8+1) should be in sigma: True</code></pre>
</div>
</div>
<p>The mathematical property we want to check for a given function <span class="math inline">\(f: I \to \mathbb{F}\)</span> is the following:</p>
<p><span class="math display">\[\forall i \in I: f(i)= f(\sigma(i))\]</span></p>
<p>If this holds, we know that all values in our equivalence classes are equal. We can in fact check this for our permutation <span class="math inline">\(\sigma\)</span> and our three columns <span class="math inline">\(a,b,c\)</span> as follows.</p>
<div id="0161a9fc-d301-49a4-9bb4-d51e8acab5fc" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="19">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>columns <span class="op">=</span> [a, b, c]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):                      <span class="co"># rows 1…n</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        slot <span class="op">=</span> col<span class="op">*</span>n <span class="op">+</span> i                         <span class="co"># “flattened” slot in 1…3n</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        mapped <span class="op">=</span> sigma[slot]                     <span class="co"># in 1…3n</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># convert to 0-based so divmod works nicely</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        zero_slot <span class="op">=</span> mapped <span class="op">-</span> <span class="dv">1</span>                   </span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        col2, idx2_zero <span class="op">=</span> <span class="bu">divmod</span>(zero_slot, n)   <span class="co"># col2 in 0..2, idx2_zero in 0..n-1</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>        i2 <span class="op">=</span> idx2_zero <span class="op">+</span> <span class="dv">1</span>                       <span class="co"># back to 1…n indexing</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>        x1 <span class="op">=</span> ω<span class="op">**</span>(i )</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        x2 <span class="op">=</span> ω<span class="op">**</span>(i2 )</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> columns[col](x1) <span class="op">==</span> columns[col2](x2), <span class="st">"Permutation property does not hold"</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>            </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now the question is, how does the prover convince the verifier that this holds without sharing all intermediate computation values?</p>
<p>One simple way to achieve this is to run the equality testing protocol for:</p>
<p><span class="math display">\[ f \circ \sigma - f = 0 \]</span></p>
<p>over the domain <span class="math inline">\(\Omega\)</span> and an interpolated version of <span class="math inline">\(\sigma\)</span>. Unfortunately, this solution is inefficient since the composition of two polynomials of degree <span class="math inline">\(n\)</span> has degree of about <span class="math inline">\(n^2\)</span>. For instance if we compose <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> we obtain a polynomial of degree 9 (why?):</p>
<div id="b433b3bc-2c48-49e7-a974-3700c35846c5" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="20">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>a(b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>21802741923121153053822748313780136717971970536841404091162235932729973504748*x^9 + 17698696384651288949806513208156374961458495281087583232325986218843750697220*x^8 + 15219168871825746054207931767645017665721029176757758524459966167252422127810*x^7 + 13851153692335791356915520435638727170049384234971330620701598396816370310749*x^6 + 15732174564134479069295544857125849351800122391714983737485907109165176444762*x^5 + 6156068307704796159975984934541064360798461151397463593737045633796236988998*x^4 + 21717240974403030896832135899008880813987109787851132230088113368688162236738*x^3 + 12141134717973347974460997478437561320460776708896648741869253349838123410604*x^2 + 13081645153872691828051025054357947332337167624162695003407885568722756022565*x + 15817675512852601238803964089886828980501917740558913054272020360688200433438</code></pre>
</div>
</div>
<p>Instead, we are going to introduce a new protocol to approach this check in an efficient way. Fundamentally, what we want to do is to capture the “for all” quantifier where we check <span class="math inline">\(f(\sigma(i))\)</span> with <span class="math inline">\(f(i)\)</span> using a product, in a way that we avoid computing the costly polynomial composition.</p>
<p>To motivate the concrete algorithm, consider the following. Assume <span class="math inline">\(h\)</span> is a cryptographically secure hash function. If we compute</p>
<p><span class="math display">\[GP = \prod_{i=1}^n \frac{h(i,f(i))}{h(i,f(\sigma(i)))}\]</span></p>
<p>we expect to be <span class="math inline">\(GP=1\)</span> if and only if <span class="math inline">\(f(\sigma(i))=f(i)\)</span>. One direction is easy to see, for the other one we would conclude that either there was a hash collision or some unlikely scenario arises (details are left as an exercise).</p>
<p>One useful observation is that we can write the <span class="math inline">\(GP\)</span> alternatively like this:</p>
<p><span class="math display">\[GP = \prod_{i=1}^n \frac{h(i,f(i))}{h(i,f(\sigma(i)))} = \prod_{i=1}^n \frac{h(i,f(i))}{h(\sigma(i),f(i))} \]</span></p>
<p>because the values are in the equivalence class defined by <span class="math inline">\(\sigma\)</span>. In fact, the numerator is exactly the same, and the denominator as well: noticed that on the original denominator we had <span class="math inline">\(h(\sigma(i), f(\sigma(i))\)</span> which, if the permutation holds, is equal to <span class="math inline">\(h(\sigma(i),f(i)\)</span>. But the advantage of this equivalent representation is that we do not have to explicitely compose the polynomial <span class="math inline">\(f\)</span> with <span class="math inline">\(\sigma\)</span>.</p>
<p>Now, in practice we want to have an efficient “hash” function that has the same security properties as before, such that <span class="math inline">\(GP=1\)</span> implies (with high probability) that the permutation property holds. For this we consider the class of functions:</p>
<p><span class="math display">\[h(i,f(i)) = i + \beta \cdot f(i) + \gamma\]</span></p>
<p>for random interactive challenges <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\gamma\)</span>. It is possible to show using Schwartz-Zippel that those will behave similar to the cryptographic hash function in our discussion above, but they are efficiently computable (for more details see the original paper).</p>
<p>We will now step by step construct the argument that takes advantage of this. First we start by defining a numerator and denominator functions, and their respective accumulators.</p>
<p><strong>Exercise 13</strong> Compute the numerator using the formula <span class="math display">\[ (column - 1) \cdot n + i + \beta\cdot f(\omega^i) + \gamma\]</span> and the denominator as <span class="math display">\[\sigma(column - 1) \cdot n + i + \beta\cdot f(\omega^i) + \gamma\]</span></p>
<div id="bbe263c3-b6b2-493a-b199-e4643f0f8298" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numerator(i, column,f,sigma,beta, gamma):</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!    </span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value    </span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> denominator(i, column,f,sigma,beta, gamma):</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value       </span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6a80993c-dc8a-4d20-bdb8-5e28a834f9f2" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="22">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Test cases</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>numerator(<span class="dv">3</span>,<span class="dv">1</span>,a,sigma,<span class="dv">42</span>,<span class="dv">42</span>) <span class="op">==</span> <span class="dv">87</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>denominator(<span class="dv">3</span>,<span class="dv">1</span>,a,sigma,<span class="dv">42</span>,<span class="dv">42</span>) <span class="op">==</span> <span class="dv">90</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>numerator(<span class="dv">6</span>,<span class="dv">2</span>,b,sigma,<span class="dv">42</span>,<span class="dv">42</span>) <span class="op">==</span> <span class="dv">94</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>denominator(<span class="dv">6</span>,<span class="dv">2</span>,b,sigma,<span class="dv">42</span>,<span class="dv">42</span>) <span class="op">==</span> <span class="dv">91</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>True</code></pre>
</div>
</div>
<p><strong>Exercise 14</strong> Compute accumulator functions for the numerator and the accumulator respectively as:</p>
<p><span class="math display">\[ \textsf{acc\_numerator}(i, column,f,\sigma,\beta, \gamma) = \prod_{j=1}^{i-1} \textsf{numerator}(j, column,f,\sigma,\beta, \gamma)\]</span> <span class="math display">\[ \textsf{acc\_denominator}(i, column,f,\sigma,\beta, \gamma) = \prod_{j=1}^{i-1} \textsf{denominator}(j, column,f,\sigma,\beta, \gamma)\]</span></p>
<div id="60cf23e1-d9c9-4dcf-a1b6-c97dcef32d73" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="74">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> acc_numerator(i, column,f,sigma,beta, gamma):</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    value <span class="op">=</span> <span class="dv">1</span> </span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Solve here!</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value    </span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> acc_denominator(i, column,f,sigma,beta, gamma):</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    value <span class="op">=</span> <span class="dv">1</span> </span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Solve here!</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value        </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If implemented correctly, the following check should pass.</p>
<div id="5e82e92c-4de2-4714-8119-d2c200185f57" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="24">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>N_n <span class="op">=</span> acc_numerator(n<span class="op">+</span><span class="dv">1</span>,<span class="dv">1</span>,a,sigma,<span class="dv">42</span>,<span class="dv">42</span>)<span class="op">*</span>acc_numerator(n<span class="op">+</span><span class="dv">1</span>,<span class="dv">2</span>,b,sigma,<span class="dv">42</span>,<span class="dv">42</span>)<span class="op">*</span>acc_numerator(n<span class="op">+</span><span class="dv">1</span>,<span class="dv">3</span>,c,sigma,<span class="dv">42</span>,<span class="dv">42</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>D_n <span class="op">=</span> acc_denominator(n<span class="op">+</span><span class="dv">1</span>,<span class="dv">1</span>,a,sigma,<span class="dv">42</span>,<span class="dv">42</span>)<span class="op">*</span>acc_denominator(n<span class="op">+</span><span class="dv">1</span>,<span class="dv">2</span>,b,sigma,<span class="dv">42</span>,<span class="dv">42</span>)<span class="op">*</span>acc_denominator(n<span class="op">+</span><span class="dv">1</span>,<span class="dv">3</span>,c,sigma,<span class="dv">42</span>,<span class="dv">42</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"When multiplying z for each column with the corresponding upper and lower bounds one should obtain 1:"</span>, N_n<span class="op">//</span>D_n<span class="op">==</span><span class="dv">1</span>)  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>When multiplying z for each column with the corresponding upper and lower bounds one should obtain 1: True</code></pre>
</div>
</div>
<p>Now that we have both the numerator and denominator functions, and the partial accumulators we can proceed to spell out the interactive protocol that allows the (potentially malicious) prover to prove that the permutation holds over the three columns <span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>,<span class="math inline">\(c\)</span> in an efficient way. Note that the following function has an interesting property, which is that it can be defined recursively:</p>
<p><span class="math display">\[z(i+1)= \frac{\mathsf{acc\_numerator}(i+1)}{\mathsf{acc\_denominator}(i+1)} = z(i) \cdot \frac{\mathsf{numerator}(i)}{\mathsf{denominator}(i)}\]</span></p>
<p>Moreover, the base case is <span class="math inline">\(z(1)=1\)</span>. We would like also to be able to prove that <span class="math inline">\(z(n+1)=1\)</span>, given that this represents the grand product argument when considering all indexes.</p>
<p>We can develop a succinct argument using polynomials by following these steps:</p>
<ul>
<li>We assume the prover has already commited to <span class="math inline">\(a,b,c\)</span>.</li>
<li>The verifier challenges the prover with random <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\gamma \in \mathbb{F}_p\)</span>.</li>
<li>The prover interpolates <span class="math inline">\(z\)</span> over <span class="math inline">\(\Omega\)</span> by computing each of the points for <span class="math inline">\(i=1, \dots, n\)</span>.</li>
<li>The prover interpolates polynomials <span class="math inline">\(N\)</span> and <span class="math inline">\(D\)</span> corresponding to the <span class="math inline">\(\mathsf{numerator}\)</span> and <span class="math inline">\(\mathsf{denominator}\)</span> functions.</li>
<li>The prover computes the quotient polynomial <span class="math inline">\(Q_z\)</span> for the polynomial <span class="math inline">\(z\cdot N -D\cdot z(x \cdot ω)\)</span> and commits to it.</li>
<li>The verifier checks the following two properties
<ul>
<li><span class="math inline">\(z(\omega)=1\)</span></li>
<li><span class="math inline">\(z\cdot N -D\cdot z(x \cdot ω)=0\)</span></li>
</ul></li>
</ul>
<p>It is interesting to note that in the multiplicative domain, <span class="math inline">\(z(\omega)=1\)</span> automatically implies <span class="math inline">\(z(\omega^{n+1})=1\)</span>. This follows from:</p>
<p><span class="math display">\[z(\omega^{n+1})=z(\omega^n \cdot \omega) = z(\omega) =1 \]</span></p>
<p><strong>Exercise 15</strong> Compute a function that receives as parameters the three polynomials <span class="math inline">\(a,b,c\)</span> , the challenges <span class="math inline">\(\beta, \gamma\)</span> and the domain <span class="math inline">\(\Omega\)</span> and returns the interpolation fo the <span class="math inline">\(z\)</span>, <span class="math inline">\(N\)</span> and <span class="math inline">\(D\)</span> polynomials.</p>
<div id="2232f5f2-bc76-489f-bfd0-05060ef2ebd6" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interpolate_z_N_D(a,b,c, beta, gamma, Ω):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">#TBD</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> z,N,D</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>z,N,D <span class="op">=</span> interpolate_z_N_D(a,b,c,<span class="dv">42</span>,<span class="dv">42</span>,Ω)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If computed correctly, the interpolated functions should pass the <span class="math inline">\(z(\omega)=1\)</span> check as follows.</p>
<div id="1c83680c-d7fe-4d99-8f1e-fc773062f32b" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="26">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>L1 <span class="op">=</span> prod((x <span class="op">-</span> ω<span class="op">**</span>m)<span class="op">//</span>(ω <span class="op">-</span> ω<span class="op">**</span>m) <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,n<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>L1<span class="op">=</span>R(L1)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>ZH <span class="op">=</span> R(x<span class="op">^</span>n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>(ZH).divides(L1<span class="op">*</span>(z<span class="op">-</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>True</code></pre>
</div>
</div>
<p>Moreover it should pass the following check, which proves the recursive constraint.</p>
<div id="9789d6c3-5452-4bf6-a826-f3c8bad20db6" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="27">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>(ZH).divides( z<span class="op">*</span>N <span class="op">-</span>D<span class="op">*</span>z(x<span class="op">*</span>ω))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>True</code></pre>
</div>
</div>
<p>The polynomial <span class="math inline">\(z(x) \cdot N(x) -D(x) \cdot z(x*ω)\)</span> is:</p>
<p><span class="math display">\[z(x) \cdot N(x) -D(x) \cdot z(x*ω) = 19088033315219631021107812019832839306780395371633216223270161982137379434783 x^{6} + 9442345120481651903520919226899454023736002770233426083846080860317389062734 x^{5} + 21082329243894486516657209903907612685168280090308035096051805040844722189074 x^{4} + 2800209556619644201138593725424435781767969028782818120428042204438429060834 x^{2} + 12445897751357623318725486518357821064812361630182608259852123326258419432883 x + 805913627944788705589195841349662403380084310107999247646399145731086306543
\]</span></p>
<div id="f00ca558-36de-4243-b4f9-fb5647a37dcf" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="28">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>show(z<span class="op">*</span>N <span class="op">-</span>D<span class="op">*</span>z(x<span class="op">*</span>ω))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
\(\displaystyle 19088033315219631021107812019832839306780395371633216223270161982137379434783 x^{6} + 9442345120481651903520919226899454023736002770233426083846080860317389062734 x^{5} + 21082329243894486516657209903907612685168280090308035096051805040844722189074 x^{4} + 2800209556619644201138593725424435781767969028782818120428042204438429060834 x^{2} + 12445897751357623318725486518357821064812361630182608259852123326258419432883 x + 805913627944788705589195841349662403380084310107999247646399145731086306543\)
</div>
</div>
</section>
<section id="towards-zkp" class="level2">
<h2 class="anchored" data-anchor-id="towards-zkp">7.Towards ZKP</h2>
<p>Note that although we have focused on a malicious prover so far, the verifier may deviate from the honest protocol to learn secret data from the verifier. For example, they can choose adaptive off-domain points or collude across multiple openings with the goal of extracting intermediate witness values or private inputs.</p>
<section id="blinding-via-vanishing-polynomial-multiples" class="level3">
<h3 class="anchored" data-anchor-id="blinding-via-vanishing-polynomial-multiples">Blinding via vanishing-polynomial multiples</h3>
<p>To defend against this, we mask each witness polynomial (f(x)) by adding a random multiple of the vanishing polynomial. <span class="math display">\[Z_H(x) \;=\; x^n - 1.\]</span></p>
<p>Concretely, before committing we form</p>
<p><span class="math display">\[\widetilde f(x) \;=\; f(x)\;+\;Z_H(x)\cdot p(x),\]</span></p>
<p>where <span class="math inline">\(p(x)\)</span> is drawn uniformly at random from all polynomials of degree <span class="math inline">\(&lt;k\)</span> (for some security parameter <span class="math inline">\(k\)</span>.</p>
</section>
<section id="one-fresh-blinding-factor-per-opening" class="level3">
<h3 class="anchored" data-anchor-id="one-fresh-blinding-factor-per-opening">One fresh blinding factor per opening</h3>
<p>Each time the verifier opens <span class="math inline">\(\widetilde f\)</span> at a point <span class="math inline">\(z\not\in\{\omega^i\}\)</span>, they learn</p>
<p><span class="math display">\[\widetilde f(z) \;=\; f(z)\;+\;Z_H(z)\cdot p(z)\]</span></p>
<p>which yields one linear equation in the coefficients of <span class="math inline">\(p(x)\)</span>.<br>
- If the same <span class="math inline">\(p(x)\)</span> were reused for multiple openings, a malicious verifier could gather enough of these equations to solve for <span class="math inline">\(p(x)\)</span>, then subtract <span class="math inline">\(Z_H(x)\cdot p(x)\)</span> and recover the original <span class="math inline">\(f(x)\)</span>.<br>
- To preserve zero-knowledge, we therefore allocate one independent random polynomial <span class="math inline">\(p(x)\)</span> for each distinct off-domain opening query.</p>
<p><em>Example</em> Consider the following example for blinding the witness polynomial <span class="math inline">\(a(x)\)</span>. We assume two openings on <span class="math inline">\(a(x)\)</span>, as we will see later in the full protocol.</p>
<div id="73319bba-2e21-4a39-8f4b-1d8bd3bbd388" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="29">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> R.random_element(degree<span class="op">=</span>k<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"p(x) ="</span>, p)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>a_blind <span class="op">=</span> a <span class="op">+</span> p<span class="op">*</span>ZH</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>show(a_blind)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Degree of a_blind:"</span>,a_blind.degree())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>p(x) = 7846974345743743743009628096037841263957128127461006184358032298078777836753*x + 17400493923130958490506171015032528352276895896363983356660864143955303261126</code></pre>
</div>
<div class="cell-output cell-output-display">
\(\displaystyle 7846974345743743743009628096037841263957128127461006184358032298078777836753 x^{5} + 17400493923130958490506171015032528352276895896363983356660864143955303261126 x^{4} + 16416182153879456417786784551517017277046601793284012108757927423286461067892 x^{3} + 5472060717959818805561601436314318772137091100104008585924551046643952123905 x^{2} + 19513329244055350283696398842959691636092998880087050394280448651786378086590 x + 20903931102587773148425039039167703052682741804364076744810993182552361606205\)
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Degree of a_blind: 5</code></pre>
</div>
</div>
<p><strong>Exercise 16</strong> Assuming <span class="math inline">\(b(x),c(x)\)</span> also have at most two openings, blind them similarly to <span class="math inline">\(a(x)\)</span>. Afterwards, interpolate <span class="math inline">\(z\_poly, N\_poly, D\_poly\)</span> using the given <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\gamma\)</span>. Finally blind <span class="math inline">\(z\_poly\)</span> assuming also at most 2 openings.</p>
<div id="3831f80b-eb66-4487-8552-f9e742c92ead" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> gamma <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>b_blind <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>c_blind <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>z_poly <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>N_poly <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>D_poly <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>z_poly_blind <span class="op">=</span> <span class="co">#?</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If computed correctly the following check should still pass on the blinded polynomials, because the roots of the polynomial do not change (points of the domain).</p>
<div id="177916fc-545f-4e29-a607-32301c219369" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="32">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (ZH).divides( z_poly_blind<span class="op">*</span>N_poly <span class="op">-</span>D_poly<span class="op">*</span>z_poly_blind(x<span class="op">*</span>ω)) <span class="op">==</span> <span class="va">True</span>, <span class="st">"Something went wrong"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="fiat-shamir" class="level2">
<h2 class="anchored" data-anchor-id="fiat-shamir">8.Fiat Shamir</h2>
<p>Now let’s put all the pieces together.</p>
<p>In practice, we often want a non-interactive proof system so that we can compute the proofs at one point in time on a given machine, and check them later when needed. To achieve this, we use the Fiat-Shamir transformation, where we assume a hash function behaves as a random oracle. The idea is that the prover himself can generate “unbiased” challenges based on the messages he would send to the verifier in an interactive version of the protocol by using a hash function. See for instance the following two functions that operate over a string that we will call a “transcript”.</p>
<p>The first function <span class="math inline">\(\textsf{push}\)</span> adds values to the transcript (field elements, curve elements) by using delimiters to separate them. The <span class="math inline">\(\textsf{generate\_challenge}\)</span> function will hash a given transcript and create an element in <span class="math inline">\(\mathbb{F}\)</span> from the hash.</p>
<div id="ae4aae51-2ca3-48d0-b6b4-283305a501e7" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="31">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> hashlib</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> push(v, transcript, delim<span class="op">=</span><span class="st">"|"</span>):</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> transcript <span class="op">+</span> delim <span class="op">+</span> <span class="bu">str</span>(v)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_challenge(transcript):</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Encode the transcript string into bytes for the hash function</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    transcript_bytes <span class="op">=</span> transcript.encode(<span class="st">'utf-8'</span>)</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute the SHA256 hash and get its hexadecimal representation</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    sha256_hash <span class="op">=</span> hashlib.sha256(transcript_bytes).hexdigest()</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the hexadecimal hash string to an integer</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>    hash_int <span class="op">=</span> <span class="bu">int</span>(sha256_hash, <span class="dv">16</span>)</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cast the integer into an element of our finite field F</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> F(hash_int)</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a><span class="co">#Examples</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>transcript <span class="op">=</span> <span class="st">""</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Initial transcript: '</span><span class="sc">{</span>transcript<span class="sc">}</span><span class="ss">'"</span>)</span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Push a number and an elliptic curve point to the transcript</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>transcript <span class="op">=</span> push(<span class="dv">12345</span>, transcript)</span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>transcript <span class="op">=</span> push(kzg.P, transcript)</span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Updated transcript: '</span><span class="sc">{</span>transcript<span class="sc">}</span><span class="ss">'"</span>)</span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a><span class="co"># # Generate a challenge from the transcript</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>challenge <span class="op">=</span> generate_challenge(transcript)</span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Generated challenge: </span><span class="sc">{</span>challenge<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Initial transcript: ''
Updated transcript: '|12345|(1 : 2 : 1)'
Generated challenge: 19685844868109878423961294678126802425998569544130367002668967398805728209250</code></pre>
</div>
</div>
<p><strong>Step 1</strong> We start with an empty transcript and add the initial values <span class="math inline">\(a(\omega)\)</span> and <span class="math inline">\(b(\omega)\)</span> which should be <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> to the transcript, as well as the output <span class="math inline">\(c(\omega^4)\)</span> which should be 9. We also add commitments to the blinded polynomials <span class="math inline">\(a\_blind, b\_blind, c\_blind\)</span>.</p>
<p><strong>Exercise 17</strong> Push the values discussed above in order to the empty transcript. Also compute proofs for the openings of <span class="math inline">\(a,b,c\)</span> corresponding to the inputs and output. Proofs are not added to the transcript.</p>
<div id="ac28466f-72b3-4faa-b50f-3665ec0ad95e" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>transcript <span class="op">=</span> <span class="st">""</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>value_a <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>value_b <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>value_c <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>c_a <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>c_b <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>c_c <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>proof_value_a       <span class="op">=</span> </span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>proof_value_b       <span class="op">=</span> </span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>proof_output  <span class="op">=</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Step 2</strong> We now compute the challenges <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\gamma\)</span> for the permutation argument from the transcript, one at a time and then push them to the transcript. With these values we can compute the <span class="math inline">\(z\)</span>, <span class="math inline">\(N\)</span> and <span class="math inline">\(D\)</span> polynomials.</p>
<p><strong>Exercise 18</strong> Compute <span class="math inline">\(\beta\)</span> from the transcript and push this value to it. Then compute <span class="math inline">\(\gamma\)</span> and similarly, push it to the transcript. Finally interpolate values for <span class="math inline">\(z, N,D\)</span> and commit <span class="math inline">\(z\)</span> to the transcript.</p>
<div id="0202a3ba-5b22-49bf-8ef2-af3295b1115b" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="co"># interpolate and commit z</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>z_poly, N_poly, D_poly <span class="op">=</span> <span class="co">#?</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>c_z <span class="op">=</span> <span class="co">#?</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Step 3</strong> We are now going to build a “master polynomial” which will encode the gate constraints and the permutation constraints in one, which will be more efficient and equivalent to checking each constrain separately.</p>
<p><strong>Exercise 19</strong> Generate a challenge <span class="math inline">\(\alpha\)</span> and push it to the transcript. Compute the gates constraing on the blinded polynomials:</p>
<p><span class="math display">\[ t\_gates = qM \cdot a\_blind \cdot b\_blind + qL \cdot a\_blind + qR \cdot b\_blind - c\_blind\]</span></p>
<p>Then compute the <span class="math inline">\(L_1\)</span> function as above and the constraints:</p>
<p><span class="math display">\[ t\_perm\_start = (z\_poly - 1) \cdot L_1\]</span></p>
<p><span class="math display">\[ t\_perm\_step = z\_poly \cdot N\_poly - D\_poly \cdot z\_poly(x \cdot \omega)\]</span></p>
<p>Compute the master polynomial:</p>
<p><span class="math display">\[ bigt = t\_gates + \alpha \cdot t\_perm\_start + \alpha^2 \cdot t\_perm\_step \]</span></p>
<p>and its quotient:</p>
<p><span class="math display">\[ quotient\_poly = \frac{bigt}{ZH}\]</span></p>
<p>Commit to <span class="math inline">\(quotient\_poly\)</span> and push to the transcript.</p>
<div id="d158e3b0-0a87-414f-9bd3-a93ce0cb804e" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Solve here!</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> </span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>L1 <span class="op">=</span> </span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>t_gates     <span class="op">=</span> </span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>t_perm_start<span class="op">=</span> </span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>z_shifted   <span class="op">=</span> </span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>t_perm_step <span class="op">=</span> </span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>bigt <span class="op">=</span>  </span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>quotient_poly <span class="op">=</span> </span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>c_t <span class="op">=</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Step 5</strong> Now we generate the <span class="math inline">\(\zeta\)</span> challenge to open <span class="math inline">\(a,b,c\)</span> (blinded) and <span class="math inline">\(quotient\_poly, z\_poly\)</span> at <span class="math inline">\(\zeta\)</span>. This will later allow the verifier to independently recompute the constraint polynomials. We also need an opening of <span class="math inline">\(z\_poly\)</span> at <span class="math inline">\(\zeta \cdot \omega\)</span>.</p>
<p><strong>Exercise 20</strong> Compute <span class="math inline">\(\zeta\)</span> from the transcript and push it. Then compute the evaluations of the blinded <span class="math inline">\(a,b,c\)</span>, as well as the quotient polynomial and <span class="math inline">\(z\)</span>. Compute the proofs for each of these evaluations.</p>
<div id="ce650246-4143-4c1f-871c-e04444d8110d" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>zeta <span class="op">=</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>a_zeta <span class="op">=</span> <span class="op">;</span>    b_zeta <span class="op">=</span> <span class="op">;</span>    c_zeta <span class="op">=</span> </span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>z_zeta <span class="op">=</span> <span class="op">;</span>     t_zeta <span class="op">=</span> </span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>z_zeta_omega <span class="op">=</span> </span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="co"># individual KZG proofs</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>proof_a       <span class="op">=</span> </span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>proof_b       <span class="op">=</span> </span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>proof_c       <span class="op">=</span> </span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>proof_z       <span class="op">=</span> </span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>proof_t       <span class="op">=</span> </span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>proof_z_omega <span class="op">=</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally we collect all proof artifacts we need to share with the verifier so that they can independently reconstruct the transcript and check the expected values and commitment proofs on their side.</p>
<div id="892a28b3-161a-4f05-b100-200579cae2f2" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="37">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 6. Collect everything to send to the verifier</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>proof_dictionary <span class="op">=</span> {</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'commitments'</span>: {</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">'c_a'</span>: c_a,</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">'c_b'</span>: c_b,</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">'c_c'</span>: c_c,</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">'c_z'</span>: c_z,</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">'c_t'</span>: c_t</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    },</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'challenges'</span>: {</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">'beta'</span>: beta,</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">'gamma'</span>: gamma,</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">'alpha'</span>: alpha,</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">'zeta'</span>: zeta</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    },</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'evaluations'</span>: {</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">'value_a'</span>: value_a,</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">'value_b'</span>: value_b,</span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>        <span class="st">'output'</span>: output,</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>        <span class="st">'a_zeta'</span>: a_zeta,</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>        <span class="st">'b_zeta'</span>: b_zeta,</span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>        <span class="st">'c_zeta'</span>: c_zeta,</span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>        <span class="st">'z_zeta'</span>: z_zeta,</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>        <span class="st">'t_zeta'</span>: t_zeta,</span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>        <span class="st">'z_zeta_omega'</span>: z_zeta_omega</span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>    },</span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a>    <span class="st">'proofs'</span>: {</span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a>        <span class="st">'proof_value_a'</span>:proof_value_a,</span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a>        <span class="st">'proof_value_b'</span>:proof_value_b,</span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a>        <span class="st">'proof_output'</span>: proof_output,</span>
<span id="cb51-31"><a href="#cb51-31" aria-hidden="true" tabindex="-1"></a>        <span class="st">'proof_a'</span>: proof_a,</span>
<span id="cb51-32"><a href="#cb51-32" aria-hidden="true" tabindex="-1"></a>        <span class="st">'proof_b'</span>: proof_b,</span>
<span id="cb51-33"><a href="#cb51-33" aria-hidden="true" tabindex="-1"></a>        <span class="st">'proof_c'</span>: proof_c,</span>
<span id="cb51-34"><a href="#cb51-34" aria-hidden="true" tabindex="-1"></a>        <span class="st">'proof_z'</span>: proof_z,</span>
<span id="cb51-35"><a href="#cb51-35" aria-hidden="true" tabindex="-1"></a>        <span class="st">'proof_t'</span>: proof_t,</span>
<span id="cb51-36"><a href="#cb51-36" aria-hidden="true" tabindex="-1"></a>        <span class="st">'proof_z_omega'</span>: proof_z_omega</span>
<span id="cb51-37"><a href="#cb51-37" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb51-38"><a href="#cb51-38" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb51-39"><a href="#cb51-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-40"><a href="#cb51-40" aria-hidden="true" tabindex="-1"></a><span class="co"># proof_dictionary is now ready for the verifier.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="verifier" class="level2">
<h2 class="anchored" data-anchor-id="verifier">Verifier</h2>
<p>Now all that is left for the verifier is to reconstruct step by step the transcript and check that everything passes! If you implemented the above exercises correctly, this check should pass.</p>
<div id="e183a6b7-87ea-4da7-a093-9d6daac877b9" class="cell" data-editable="true" data-quarto-private-1="{&quot;key&quot;:&quot;slideshow&quot;,&quot;value&quot;:{&quot;slide_type&quot;:&quot;&quot;}}" data-tags="[]" data-execution_count="38">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> verify_plonk(proof_dictionary):</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 0. Reconstruct transcript</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    transcript <span class="op">=</span> <span class="st">""</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (value_a <span class="op">!=</span> <span class="dv">0</span> <span class="kw">or</span> value_b <span class="op">!=</span> <span class="dv">1</span>):</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>, <span class="st">"Input values are not correct"</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Round 1: commitments to a, b, c</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name <span class="kw">in</span> (<span class="st">'value_a'</span>,<span class="st">'value_b'</span>,<span class="st">'output'</span>):</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>        transcript <span class="op">=</span> push(proof_dictionary[<span class="st">'evaluations'</span>][name], transcript)    </span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name <span class="kw">in</span> (<span class="st">'c_a'</span>,<span class="st">'c_b'</span>,<span class="st">'c_c'</span>):</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>        transcript <span class="op">=</span> push(proof_dictionary[<span class="st">'commitments'</span>][name], transcript)</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Round 2: beta, gamma</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>    beta_v <span class="op">=</span> generate_challenge(transcript)</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> beta_v <span class="op">!=</span> proof_dictionary[<span class="st">'challenges'</span>][<span class="st">'beta'</span>]:</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(beta_v, proof_dictionary[<span class="st">'challenges'</span>][<span class="st">'beta'</span>])</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>, <span class="st">"beta mismatch"</span></span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>    transcript <span class="op">=</span> push(beta_v, transcript)</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>    gamma_v <span class="op">=</span> generate_challenge(transcript)</span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> gamma_v <span class="op">!=</span> proof_dictionary[<span class="st">'challenges'</span>][<span class="st">'gamma'</span>]:</span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>, <span class="st">"gamma mismatch"</span></span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a>    transcript <span class="op">=</span> push(gamma_v, transcript)</span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># append z commitment</span></span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a>    transcript <span class="op">=</span> push(proof_dictionary[<span class="st">'commitments'</span>][<span class="st">'c_z'</span>], transcript)</span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Round 3: alpha</span></span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a>    alpha_v <span class="op">=</span> generate_challenge(transcript)</span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> alpha_v <span class="op">!=</span> proof_dictionary[<span class="st">'challenges'</span>][<span class="st">'alpha'</span>]:</span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>, <span class="st">"alpha mismatch"</span></span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a>    transcript <span class="op">=</span> push(alpha_v, transcript)</span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># append t commitment</span></span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a>    transcript <span class="op">=</span> push(proof_dictionary[<span class="st">'commitments'</span>][<span class="st">'c_t'</span>], transcript)</span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Round 4: zeta</span></span>
<span id="cb52-38"><a href="#cb52-38" aria-hidden="true" tabindex="-1"></a>    zeta_v <span class="op">=</span> generate_challenge(transcript)</span>
<span id="cb52-39"><a href="#cb52-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> zeta_v <span class="op">!=</span> proof_dictionary[<span class="st">'challenges'</span>][<span class="st">'zeta'</span>]:</span>
<span id="cb52-40"><a href="#cb52-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>, <span class="st">"zeta mismatch"</span></span>
<span id="cb52-41"><a href="#cb52-41" aria-hidden="true" tabindex="-1"></a>    transcript <span class="op">=</span> push(zeta_v, transcript)</span>
<span id="cb52-42"><a href="#cb52-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-43"><a href="#cb52-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-44"><a href="#cb52-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 5. Pairing checks for each opening</span></span>
<span id="cb52-45"><a href="#cb52-45" aria-hidden="true" tabindex="-1"></a>    checks <span class="op">=</span> [</span>
<span id="cb52-46"><a href="#cb52-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># inputs and output openings</span></span>
<span id="cb52-47"><a href="#cb52-47" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'c_a'</span>,          <span class="st">'proof_value_a'</span>,         <span class="st">'value_a'</span>, ω),</span>
<span id="cb52-48"><a href="#cb52-48" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'c_b'</span>,          <span class="st">'proof_value_b'</span>,         <span class="st">'value_b'</span>,ω),</span>
<span id="cb52-49"><a href="#cb52-49" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'c_c'</span>,          <span class="st">'proof_output'</span>,         <span class="st">'output'</span>,ω<span class="op">^</span><span class="dv">4</span>),</span>
<span id="cb52-50"><a href="#cb52-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># witness openings</span></span>
<span id="cb52-51"><a href="#cb52-51" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'c_a'</span>,          <span class="st">'proof_a'</span>,         <span class="st">'a_zeta'</span>, zeta_v),</span>
<span id="cb52-52"><a href="#cb52-52" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'c_b'</span>,          <span class="st">'proof_b'</span>,         <span class="st">'b_zeta'</span>,zeta_v),</span>
<span id="cb52-53"><a href="#cb52-53" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'c_c'</span>,          <span class="st">'proof_c'</span>,         <span class="st">'c_zeta'</span>,zeta_v),</span>
<span id="cb52-54"><a href="#cb52-54" aria-hidden="true" tabindex="-1"></a>        <span class="co"># z and t openings</span></span>
<span id="cb52-55"><a href="#cb52-55" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'c_z'</span>,          <span class="st">'proof_z'</span>,         <span class="st">'z_zeta'</span>,zeta_v),</span>
<span id="cb52-56"><a href="#cb52-56" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'c_t'</span>,          <span class="st">'proof_t'</span>,         <span class="st">'t_zeta'</span>,zeta_v),</span>
<span id="cb52-57"><a href="#cb52-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># z(ζ·ω) for perm check</span></span>
<span id="cb52-58"><a href="#cb52-58" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'c_z'</span>,          <span class="st">'proof_z_omega'</span>,   <span class="st">'z_zeta_omega'</span>,zeta_v<span class="op">*</span> ω ),</span>
<span id="cb52-59"><a href="#cb52-59" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb52-60"><a href="#cb52-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-61"><a href="#cb52-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (c_key, π_key, b_key, challenge_point) <span class="kw">in</span> checks:</span>
<span id="cb52-62"><a href="#cb52-62" aria-hidden="true" tabindex="-1"></a>        C <span class="op">=</span> proof_dictionary[<span class="st">'commitments'</span>][c_key]</span>
<span id="cb52-63"><a href="#cb52-63" aria-hidden="true" tabindex="-1"></a>        π <span class="op">=</span> proof_dictionary[<span class="st">'proofs'</span>][π_key]</span>
<span id="cb52-64"><a href="#cb52-64" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> proof_dictionary[<span class="st">'evaluations'</span>][b_key]</span>
<span id="cb52-65"><a href="#cb52-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-66"><a href="#cb52-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> verification(C, π, challenge_point, b):</span>
<span id="cb52-67"><a href="#cb52-67" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span>, <span class="ss">f"Pairing check failed for </span><span class="sc">{</span>c_key<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb52-68"><a href="#cb52-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-69"><a href="#cb52-69" aria-hidden="true" tabindex="-1"></a>    qL_z <span class="op">=</span> qL(zeta_v)</span>
<span id="cb52-70"><a href="#cb52-70" aria-hidden="true" tabindex="-1"></a>    qR_z <span class="op">=</span> qR(zeta_v)</span>
<span id="cb52-71"><a href="#cb52-71" aria-hidden="true" tabindex="-1"></a>    qM_z <span class="op">=</span> qM(zeta_v)</span>
<span id="cb52-72"><a href="#cb52-72" aria-hidden="true" tabindex="-1"></a>    N_z <span class="op">=</span> N_poly(zeta_v)</span>
<span id="cb52-73"><a href="#cb52-73" aria-hidden="true" tabindex="-1"></a>    D_z <span class="op">=</span> D_poly(zeta_v)</span>
<span id="cb52-74"><a href="#cb52-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-75"><a href="#cb52-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check 1: Gate constraints</span></span>
<span id="cb52-76"><a href="#cb52-76" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-77"><a href="#cb52-77" aria-hidden="true" tabindex="-1"></a>    t_gates_v <span class="op">=</span> qM_z<span class="op">*</span>a_zeta<span class="op">*</span>b_zeta <span class="op">+</span> qL_z<span class="op">*</span>a_zeta<span class="op">+</span>qR_z<span class="op">*</span>b_zeta<span class="op">-</span>c_zeta</span>
<span id="cb52-78"><a href="#cb52-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-79"><a href="#cb52-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check 2: Permutation constraints</span></span>
<span id="cb52-80"><a href="#cb52-80" aria-hidden="true" tabindex="-1"></a>    L1_z <span class="op">=</span> L1(zeta_v)</span>
<span id="cb52-81"><a href="#cb52-81" aria-hidden="true" tabindex="-1"></a>    t_perm_start_v <span class="op">=</span> (z_zeta <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> L1_z</span>
<span id="cb52-82"><a href="#cb52-82" aria-hidden="true" tabindex="-1"></a>    t_perm_step_v <span class="op">=</span> z_zeta <span class="op">*</span> N_z <span class="op">-</span> D_z <span class="op">*</span> z_zeta_omega</span>
<span id="cb52-83"><a href="#cb52-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-84"><a href="#cb52-84" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check 3: Quotient constraint</span></span>
<span id="cb52-85"><a href="#cb52-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reconstruct the value of the master polynomial at zeta</span></span>
<span id="cb52-86"><a href="#cb52-86" aria-hidden="true" tabindex="-1"></a>    master_poly_v <span class="op">=</span> t_gates_v <span class="op">+</span> alpha_v <span class="op">*</span> t_perm_start_v <span class="op">+</span> alpha_v<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> t_perm_step_v</span>
<span id="cb52-87"><a href="#cb52-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-88"><a href="#cb52-88" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reconstruct the value of the vanishing polynomial at zeta</span></span>
<span id="cb52-89"><a href="#cb52-89" aria-hidden="true" tabindex="-1"></a>    ZH_z <span class="op">=</span> zeta_v<span class="op">**</span>n <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb52-90"><a href="#cb52-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-91"><a href="#cb52-91" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The final check: Does the master polynomial identity hold?</span></span>
<span id="cb52-92"><a href="#cb52-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> master_poly_v <span class="op">==</span> t_zeta <span class="op">*</span> ZH_z:</span>
<span id="cb52-93"><a href="#cb52-93" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Quotient constraint holds."</span>)</span>
<span id="cb52-94"><a href="#cb52-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb52-95"><a href="#cb52-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>, <span class="st">"Quotient constraint check failed!"</span>    </span>
<span id="cb52-96"><a href="#cb52-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-97"><a href="#cb52-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span>, <span class="st">"All checks passed!"</span></span>
<span id="cb52-98"><a href="#cb52-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-99"><a href="#cb52-99" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Example invocation ---</span></span>
<span id="cb52-100"><a href="#cb52-100" aria-hidden="true" tabindex="-1"></a>ok, msg <span class="op">=</span> verify_plonk(proof_dictionary)</span>
<span id="cb52-101"><a href="#cb52-101" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Verifier result:"</span>, ok, msg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Quotient constraint holds.
Verifier result: True All checks passed!</code></pre>
</div>
</div>
</section>
<section id="recap-and-conclusions" class="level2">
<h2 class="anchored" data-anchor-id="recap-and-conclusions">9.Recap and conclusions</h2>
<p>In this notebook we have introduce PLONK by means of a step by step reconstruction of the main ideas in the original paper. We have taken some liberties regarding the exact details as in the original paper for simplicity of exposition. However we have tried to stay as faithful as possible to the main ideas, while sometimes sacrificing efficiency optimization for clarity of explanation.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>