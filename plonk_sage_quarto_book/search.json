[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "How to ùí´ùî©ùî¨ùî´ùí¶",
    "section": "",
    "text": "1.Introduction\nWelcome! In this notebook we illustrate the PLONK zero-knowledge-proof protocol on a simple example that we will progressively make more complete. The goal is to understand the mathematical inner workings of the protocol, down to the level of cryptographic pairings and commitment schemes. The PLONK protocol has various phases each of which involves technical steps in order to achieve certain protocol subgoals.\nThere are a couple alternative ways you can use this tutorial:\nNote: It is highly recommended you use Sage solve the exercises below in order to take advantage of its libraries, and of our implementation of the algebra needed for pairings over the bn254 curve.\nIf you have any feedback or comments do let us know at martin\\(@\\)zksecurity\\(.\\)xyz.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>1.Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "How to ùí´ùî©ùî¨ùî´ùí¶",
    "section": "",
    "text": "You can download the Jupyter Notebook version and run it locally on a Sage kernel or on the cloud on Cocalc.\nYou can follow this page and implement the solutions locally in Sage or some other programming language. We aim at giving deterministic test cases to guide you.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>1.Introduction</span>"
    ]
  },
  {
    "objectID": "2_A_first_example.html",
    "href": "2_A_first_example.html",
    "title": "2.A first example",
    "section": "",
    "text": "Consider the following scenario: You have a low resource device \\(V\\) (a validator) that can delegate computations to a processor \\(P\\), which has more computing capabilities. Sometimes the processor \\(P\\) makes mistakes in the computations, so \\(V\\) wants to do some sanity checks on \\(V\\) to make sure the final value of the computation is correct.\n\nFibonacci Example\nFor example, let‚Äôs assume that \\(V\\) asks \\(P\\) to compute the \\(4\\)-th Fibonacci number squared, that is \\(F_{4}^2\\). Recall that the Fibonacci sequence is defined by:\n\\[F_n = F_{n-1} + F_{n-2}\\]\nwith the base cases \\(F_0 = 0\\) and \\(F_1 = 1\\).\nNote that this computation can be expressed as a circuit as illustrated in Figure 1.\n\n\n\nThe goal of this example will be to design a first simple protocol that allows us to validate whether this circuit has been correctly evaluated by the processor \\(P\\) without having to recompute every single intermediate state (wire value) of the circuit. In other words the question is: can we devise a protocol that can (efficiently) guarantee that the \\(F_{4}\\) value of the sequence has been correctly computed and then squared? Are the base cases \\(F_0\\) and \\(F_1\\) correct, and have all intermediate computations of the circuit correctly performed?\nTo achieve this, let us start by picturing the circuit and all intermediate computations as a table. Consider the following picture.\n\n\n\nNote that the condition that \\(F_4^2\\) is correctly computed according to the Fibonacci recursive definition is equivalent to the following conditions:\n\nThe left and right inputs to the first gate are \\(0\\) and \\(1\\) respectively.\nFor all gates 1 to 3 the output is computed as the sum of the left and right inputs\nFor gates 2 and 3 the left input of gate \\(k\\) is equal to the right input to gate \\(k-1\\) and the right input of gate \\(k\\) is the output of gate \\(k-1\\).\nFor gate 4, the left and right inputs are the output of gate 3, and the output is the multiplication of the inputs.\n\nWe can visualize this as follows:\n\n\n\nOr mathematically, consider the set of indexes \\(I=\\{1,2,3,4\\}\\) and denote the left inputs as a function \\[LI: I \\to \\mathbb{N}\\] and similarly the right inputs \\(RI\\) and the outputs \\(O\\). Then we could say:\n\\[\\begin{aligned}\n&LI(1)=0,\\quad RI(1)=1,\\\\\n&\\forall i \\in I\\setminus \\{4\\} : LI(i)+RI(i) = O(i),\\\\\n& \\forall i \\in I\\setminus \\{3,4\\}:  \\bigl(LI(i+1) = RI(i)\\bigr)\\;\\wedge\\;\\bigl(RI(i+1)=O(i)\\bigr),\\\\\n&LI(4)=RI(4) = O(3),\\\\   \n&LI(4)*RI(4) = O(4),\\\\\n&\\implies\\quad O(4) = F_4^2.\n\\end{aligned}\\]\nSo if the processor \\(P\\) can convince the validator \\(V\\) that the above defined constraints hold for the table representation of the circuit computation, then the validator will be convinced that \\(F_4^2\\) was computed correctly. Let us now explore a way to do so by leveraging on polynomials and so-called zero-equality tests.\n\n\nInterpolation and Zero-equality tests\nA trivial way for the verifier to check if the constraints on the circuit hold would be to get copies of \\(LI,RI\\) and \\(O\\) and check them. But this would defeat the purpose of delegating the computation, because the amount of work that the prover has to do is equivalent to recomputing \\(F_4^2\\) on his own. To make this more efficient, consider the following encoding of the vectors \\(LI,RI\\) and \\(O\\): suppose there was an easy way to transform those vectors into polynomials \\(a(x),b(x),c(x)\\) such that, for every index \\(i \\in I\\), \\(a(i) = LI(i)\\), \\(b(i)= RI(i)\\) and \\(c(i)=O(i)\\).\nIf this was possible, then the processor \\(P\\) could hand in \\(a(x),b(x)\\) and \\(c(x)\\) to the validator, who can compute:\n\\[ t(x) = a(x) + b(x) - c(x)\\]\nThis polynomial has the property that for all indexes \\(i \\in I\\setminus{4}\\), \\(t(i) = 0\\).\nAdditionally, the validator needs to check that:\n\\[ t'(x) = a(x)*b(x) - c(x)\\]\nis zero for \\(x=4\\).\n\nSelectors\nIn order to simplify those checks, PLONK introduces the so-called selector columns (and their respective polynomials as follows). Consider three boolean vectors \\(SL, SR, SM\\) such that \\(SL\\) and \\(SR\\) are set if a given index contains an addition gate, and zero otherwise. Likewise, \\(SM\\) will be set whenever there is a multiplication gate. Their polynomial version satisfy \\(qL(i) = SL(i), qR(i)=SR(i), qM(i)=SM(i)\\). Then we could compress checks for both addition and multiplication gates into one:\n\\[t(x)= qL(x) \\cdot a(x) + qR(x) \\cdot b(x) + qM(x) \\cdot (a(x) \\cdot b(x)) - c(x) \\]\nThis polynomial should now be 0 for all \\(i \\in I\\).\n\n\nWiring constraints\nMoreover, we could also encode the missing constraints as follows:\n\\[ f_1(x) = a(x+1) - b(x)\\] \\[f_2(x) = b(x+1) - c(x)\\]\nThese two should also be zero at all but the last two indexes, \\(i \\in I \\setminus{\\{3,4\\}}\\). Last we need to check:\n\\[f_3(x) = b(x) - c(x-1)\\]\n\\[f_4(x) = a(x) - b(x)\\]\nwhich should hold for \\(x=4\\).\nSo by encoding the vectors \\(L,R,O\\) into polynomials \\(a(x),b(x),c(x)\\), a validator \\(V\\) could in principle check all that is needed to convince themselves that \\(F_4^2 = c(4)\\) was computed correctly.\nLet us begin implementing these ideas before building our (still preliminary) validation protocol. Although mathematically the Fibonacci function is defined over the naturals \\(\\mathbb{N}\\), when implementing zero-knowledge proofs we crucially do all arithmetic in a finite field \\(\\mathbb{F}_p\\), meaning values are taken modulo a prime \\(p\\). There are various reasons why this is done. First, many cryptographic constructions rely on the difficulty of certain discrete problems over finite fields. Also, working on a field ensures every nonzero element has a multiplicative inverse, which will be useful in the following to reason about operations over polynomials. Last, arithmetic modulo \\(p\\) is straightforward to implement and typically efficient.\nExercise 1 Represent the vectors \\(LI,RI,O,SL,SR,SM\\) as polynomials \\(a,b,c\\) over the finite field defined by \\[p = 21888242871839275222246405745257275088548364400416034343698204186575808495617.\\] This prime number is the order of the bn254 elliptic curve, which will be useful in the following. To interpolate the polynomials use Lagrange interpolation as follows. Given a set of points \\(X = \\{x_1,x_2,\\dots,x_n\\}\\) and data \\((x_i,y_i)\\) for each \\(i \\in I\\), the interpolating polynomial \\(f(x)\\):\n\\[\nf(x)\n=\n\\sum_{j \\in I}\n\\Bigl(\n  y_j\n  \\prod_{\\substack{i \\in I \\\\ i \\neq j}}\n  \\frac{x - x_i}{x_j - x_i}\n\\Bigr)\n\\;\\in\\;\\mathbb{F}_p[x].\n\\]\n\ndef interpolate(I, Y):\n    #Solve here!\n    return f\n\np = 21888242871839275222246405745257275088548364400416034343698204186575808495617\nF = GF(p)\nR.&lt;x&gt; = PolynomialRing(F, 'x')   \n\nLI = \nRI = \nO = \nI = \n\nSL=\nSR=\nSM=\n\n\nqL = \nqR = \nqM = \n\n\na =\nb = \nc =\n\nIf computed correctly you should be able to check the following properties on the polynomials:\n\nThey are all polynomials of degree 3 over \\(\\mathbb{F}_p\\)\nWhen evaluated over the indexes \\(I\\) you get the expected values as defined by \\(L,R,O\\).\nWhen defining \\(t = a(x) + b(x) - c(x)\\) you get 0 over the indexes \\(I\\).\n\nFor example, the first polynomial is:\n\\[\n\\begin{align}\na(x) =\\;& 10944121435919637611123202872628637544274182200208017171849102093287904247809\\, x^{3} \\\\\n      +\\;& 10944121435919637611123202872628637544274182200208017171849102093287904247805\\, x^{2} \\\\\n      +\\;& 8\\,x \\\\\n      +\\;& 21888242871839275222246405745257275088548364400416034343698204186575808495612\n\\end{align}\n\\]\n\nall = True\nfor i in I:\n    all = all and (a(i) == LI[i-1])\nprint(\"Is a(x) correctly interpolated?\", all)\nall = True\nfor i in I:\n    all = all and (b(i) == RI[i-1])\nprint(\"Is b(x) correctly interpolated?\", all)\nall = True\nfor i in I:\n    all = all and (c(i) == O[i-1])\nprint(\"Is c(x) correctly interpolated?\", all)\nall = True\nt = qM*a*b + qL*a+qR*b-c\nfor i in I:\n    all = all and (t(i) == 0)\nprint(\"Is  t =qM*a*b + qL*a+qR*b-c zero over all indexes?\", all)\n\nIs a(x) correctly interpolated? True\nIs b(x) correctly interpolated? True\nIs c(x) correctly interpolated? True\nIs  t =qM*a*b + qL*a+qR*b-c zero over all indexes? True\n\n\nAt this point we can also check the recursive constraints.\n\nf1 = a(x+1)-b(x)\nall = True\nfor i in I[:2]:\n    all = all and ( f1(i) == 0)\nprint(\"Is f1(x) = a(x+1)- b(x) zero over all indexes minus the last?\", all)\n\nf2 = b(x+1)-c(x)\nall = True\nfor i in I[:2]:\n    all = all and ( f1(i) == 0)\nprint(\"Is f2(x) = b(x+1)- c(x) zero over all indexes minus the last?\", all)\n\nIs f1(x) = a(x+1)- b(x) zero over all indexes minus the last? True\nIs f2(x) = b(x+1)- c(x) zero over all indexes minus the last? True\n\n\n\n\n\nAlternative zero-equality testing\nNow, remember we want to build a protocol that is more efficient than recomputing the original function. In the checks above, we were looping through the values of \\(I\\) to check for zero equality. We can take advantage of the algebraic properties of the interpolated polynomials to do this in a different way, which will lead to a more efficient algorithm for arbitrary circuits.\nIn fact, since we are working on a field, we know that if \\(t(x)=0\\) for every index \\(i \\in I\\), then the polynomial \\((x-i)\\) divides \\(t(x)\\), and therefore the polynomial \\(Z(x) = \\prod_{i \\in I} (x-i)\\) divides \\(t(x)\\). Equivalently, there must exist a quotient polynomial \\(Q(x) \\in \\mathbb{F}[x]\\) such that:\n\\[ t(x) = Q(x) \\cdot Z(x)\\]\nChecking this relation for the right ‚Äúvanishing‚Äù polynomial Z replaces the need for looping over all indexes.\nExercise 2: Compute \\(Z(x)\\) and quotient \\(Q(x)\\) for \\(t(x)\\). Also compute \\(Z'(x)\\) for \\(I' = I \\setminus{\\{3,4\\}}\\) and the corresponding \\(Q_1(x)\\) and \\(Q_2(x)\\) for the recursive constraint polynomials \\(f_1\\) and \\(f_2\\).\n\n#Solve here!\n\nZ = \nQ = \nZ1 = \nQ1 = \nQ2 = \n\nIf computed correctly you should get:\n\\[\n\\begin{align}\nQ(x) =\\;& 304003373219989933642311190906351042896505061116889365884697280369108451328\\, x^{5} \\\\\n      +\\;& 18240202393199396018538671454381062573790303667013361953081836822146507079681\\, x^{4} \\\\\n      +\\;& 15504172034219486615757870736223903187721758116961357660119561298824531017728\\, x^{3} \\\\\n      +\\;& 12160134928799597345692447636254041715860202444675574635387891214764338053122\\, x^{2} \\\\\n      +\\;& 7296080957279758407415468581752425029516121466805344781232734728858602831871\\, x \\\\\n      +\\;& 7296080957279758407415468581752425029516121466805344781232734728858602831873\n\\end{align}\n\\]\nWe can also do the sanity check of recovering \\(t\\) from \\(Q\\) and \\(Z\\).\n\nprint(\"Is t(x) = Q(x) * Z(x)?\", t == Q*Z)\nshow(\"Q=\",Q)\nprint(\"Is f1(x) = Q1(x) * Z1(x)?\", f1 == Q1*Z1)\nshow(\"Q1=\",Q1)\nprint(\"Is f2(x) = Q2(x) * Z1(x)?\", f2 == Q2*Z1)\nshow(\"Q2=\",Q2)\n\nIs t(x) = Q(x) * Z(x)? True\n\n\n\\(\\displaystyle \\verb|Q=| 304003373219989933642311190906351042896505061116889365884697280369108451328 x^{5} + 18240202393199396018538671454381062573790303667013361953081836822146507079681 x^{4} + 15504172034219486615757870736223903187721758116961357660119561298824531017728 x^{3} + 12160134928799597345692447636254041715860202444675574635387891214764338053122 x^{2} + 7296080957279758407415468581752425029516121466805344781232734728858602831871 x + 7296080957279758407415468581752425029516121466805344781232734728858602831873\\)\n\n\nIs f1(x) = Q1(x) * Z1(x)? True\n\n\n\\(\\displaystyle \\verb|Q1=| 7296080957279758407415468581752425029516121466805344781232734728858602831873 x + 10944121435919637611123202872628637544274182200208017171849102093287904247807\\)\n\n\nIs f2(x) = Q2(x) * Z1(x)? True\n\n\n\\(\\displaystyle \\verb|Q2=| 21888242871839275222246405745257275088548364400416034343698204186575808495616 x + 3\\)\n\n\n\nRecap and First Protocol\nWe now have the tools to define a preliminary validation protocol for computing the squared 4th Fibonacci number. Here‚Äôs an outline of each party‚Äôs steps:\n\n1. Setup\n\n(Both) Fix a working field \\(\\mathbb{F}_p\\) and note that we will interpolate polynomials of degree \\(\\le 3\\).\n(Both) Compute selector polynomials \\(qL,qR,qM\\) corresponding to this circuit.\n\n\n\n2. Prover Computation\n\n(Prover \\(P\\)) Computes the 4th Fibonacci number squared \\(F_4^2\\) by forming a table of intermediate values, then interpolates them as 3rd-degree polynomials: \\[\na(x), \\quad b(x), \\quad c(x).\n\\]\nas well as selectors \\(qL(x), \\quad qR(x), \\quad qM(x)\\).\n(Prover \\(P\\)) Computes \\[\nt(x)= qL(x) \\cdot a(x) + qR(x) \\cdot b(x) + qM(x) \\cdot (a(x) \\cdot b(x)) - c(x)\n\\] as well as the quotient polynomial \\(Q(x)\\) satisfying \\[\nt(x) \\;=\\; Q(x)\\,\\cdot Z(x).\n\\]\n(Prover \\(P\\)) Similarly constructs \\[\nf_1(x) \\;=\\; a(x+1) \\;-\\; b(x),\n\\quad\nf_2(x) \\;=\\; b(x+1) \\;-\\; c(x),\n\\] along with their quotient polynomials \\[\nQ_1(x), \\quad Q_2(x)\n\\] using \\(Z_1(x)\\) for the domain \\(\\{1,2\\}\\).\n\n\n\n3. Prover ‚Üí Verifier Communication\n\n(Prover \\(P\\)) Sends the polynomials \\[\na(x), \\; b(x), \\; c(x), \\; Q(x), \\; Q_1(x), \\; Q_2(x)\n\\] to the Validator \\(V\\).\n\n\n\n4. Verifier Checks\n\n(Verifier \\(V\\)) Checks the base conditions: \\[\na(1) \\;=\\; 0,\n\\quad\nb(1) \\;=\\; 1.\n\\]\n(Verifier \\(V\\)) Computes \\(t(x) = qL(x) \\cdot a(x) + qR(x) \\cdot b(x) + qM(x) \\cdot (a(x) \\cdot b(x)) - c(x)\\) and verifies \\[\nt(x) \\;=\\; Q(x)\\,\\cdot Z(x).\n\\] That is, \\(t(x)\\) is indeed divisible by \\(Z(x)\\).\n(Verifier \\(V\\)) Checks the recursive constraints: \\[\nf_1(x) \\;=\\; Q_1(x)\\,\\cdot Z_1(x),\n\\quad\nf_2(x) \\;=\\; Q_2(x)\\,\\cdot Z_1(x).\n\\]\n(Verifier \\(V\\)) Checks the square gate constraints: \\[\nf_3(4) \\;=\\; c(3)-b(4)=0 ,\n\\quad\nf_4(4) \\;=\\; a(4)-b(4)= 0.\n\\]\n(Verifier \\(V\\)) If all checks pass, the Verifier concludes \\[\nc(4) \\; \\text{is the correct value of } F_4^2.\n\\]\n\n\n\n\nThis protocol is correct but seems quite inefficient: instead of doing only 3 additions and one multiplication, we end up performing polynomial multiplications of polynomials of degree 3 over a very large prime field \\(\\mathbb{F}_p\\). We will now consider a more efficient version.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>2.A first example</span>"
    ]
  },
  {
    "objectID": "3_Towards_a_more_efficient_version.html",
    "href": "3_Towards_a_more_efficient_version.html",
    "title": "3.Towards a more efficient version",
    "section": "",
    "text": "We have considered two ways in which the validator \\(V\\) can check whether zero-equality constraints are met: either evaluating the constraint for reach gate of the circuit (i.e.¬†evaluating the polynomial \\(t(x)\\) encoding the sum constraint on each index), or computing the polynomial multiplication between the quotient polynomial \\(Q(x)\\) and the vanishing polynomial \\(Z(x)\\) and check equality against the polynomial encoding the constraints (i.e.¬†\\(t(x)=Q(x) \\cdot Z(x)\\)). Among the reasons why the second alternative is advantageous is that we can perform the equality check very efficient with a probabilistic algorithm at the price of (very rarely) making some mistakes.\nConsider the following algorithm:\n\nThe validator has \\(t(x)\\), \\(Q(x)\\) and \\(Z(x)\\) and wants to know whether \\(t(x) = Q(x) \\cdot Z(x)\\).\nThey sample a random value \\(\\gamma \\in \\mathbb{F}_p\\).\nThey check whether \\(t(\\gamma) = Q(\\gamma) \\cdot Z(\\gamma)\\).\n\nWhy does this work? Certainly this check is a necessary condition, that is, if the polynomial equality holds, then it also holds when evaluated on a single point. But is it sufficient? In other words, can it be that \\(t(\\gamma) = Q(\\gamma) \\cdot Z(\\gamma)\\) holds but \\(t(x) \\neq Q(x) \\cdot Z(x)\\)? It turns out that yes, that can unfortunately happen, but we can count on how many points this may at most happen, and therefore compute a probability for that event which allows us to reason on how ‚Äúrisky‚Äù our protocol is.\nCounting errors Consider two polynomials \\(f(x), g(x) \\in \\mathbb{F}_p[x]\\) of degree at most \\(d\\), such that \\(f(x) \\neq g(x)\\). Consider the set of points \\(S \\subseteq \\mathbb{F}_p\\) such that \\(\\forall s \\in S: f(s) = g(s)\\). This set of points \\(S\\) is exactly the set of points for which \\(f(x) - g(x)=0\\). By assumption \\(f(x) \\neq g(x)\\) so \\(h(x) = f(x)-g(x) \\in \\mathbb{F}_p[x]\\) is a non trivial polynomial of degree at most \\(d\\). This polynomial \\(h(x)\\) has at most \\(d\\) roots, so the size of \\(S\\) is bounded \\(|S| \\leq d\\). Given that we are sampling a value \\(\\gamma\\) uniformly at random from \\(\\mathbb{F}_p\\), the probability of selecting a point in \\(S\\), in case \\(f(x) \\neq g(x)\\), is \\(\\frac{|S|}{p} \\leq \\frac{d}{p}\\). This is known as the Schwartz-Zippel Lemma (which is more generally stated in a multi-variate polynomial setting).\nIn our circuit example, given that the polynomials involved are of degree 3, we get an extremely low probability of an incorrect equality check of at most \\(\\frac{3}{p} \\approx \\frac{1}{2^{252}}\\).\nExercise 3 Compute the equality checks for the gate and recursive constraints with the following random values: \\(\\gamma_1 = 42\\), \\(\\gamma_2 = 74102\\) and \\(\\gamma_3 = 987654321987654321\\). You should obtain:\n\\[\\begin{aligned}\nt(\\gamma_1)\n  &= Q(\\gamma_1) \\cdot Z(\\gamma_1)\n   = 21888242871839275222246405745257275088548364400416034343698204183303103172977\\\\\nf_1(\\gamma_2)\n  &= Q_1(\\gamma_2) \\cdot Z_1(\\gamma_2)\n   = 271248759392650\\\\\nf_2(\\gamma_3)\n  &= Q_2(\\gamma_3)\\cdot Z_1(\\gamma_3)\n   = 21888242871839275222245442326925691337956137906799110242993653357780575606177\n\\end{aligned}\\]\n\nŒ≥1 = 42\nŒ≥2 = 74102\nŒ≥3 = 987654321987654321\n#Solve here!\n\n\nSecond Protocol Version (Succinct, Probabilistic Check)\nThis improved protocol builds on our earlier version by using: 1. Random challenges sampled by the validator \\(\\gamma_1, \\gamma_2, \\gamma_3\\), 2. Single-point polynomial evaluations to check \\(t(\\gamma_1) = Q(\\gamma_1)\\,Z(\\gamma_1), \\quad\n     f_1(\\gamma_2) = Q_1(\\gamma_2)\\,Z_1(\\gamma_2), \\quad\n     f_2(\\gamma_3) = Q_2(\\gamma_3)\\,Z_1(\\gamma_3)\\).\nThis lowers the verification cost from a full polynomial multiplication (\\(O(d^2)\\)) to an \\(O(d)\\) evaluation, making verification more succinct.\n\n\nProtocol Flow\n\nCompute Fibonacci & Circuit Polynomials\n\n(Prover) Generates \\(F_4^2\\) by building the full circuit table.\n(Prover) Encodes the circuit columns as polynomials \\(a(x), b(x), c(x)\\).\n\nCompute Constraint Polynomials\n\n(Prover) Defines \\(t(x)= qL(x) \\cdot a(x) + qR(x) \\cdot b(x) + qM(x) \\cdot (a(x) \\cdot b(x)) - c(x)\\) and finds \\(Q(x)\\) such that \\(t(x) = Q(x) \\cdot Z(x)\\).\n(Prover) Similarly, for the recursive constraints: \\(f_1(x) = a(x+1) - b(x),\\) \\(f_2(x) = b(x+1) - c(x),\\) with quotient polynomials $ Q_1(x), Q_2(x) $ satisfying \\(f_1(x) = Q_1(x)\\cdot Z_1(x)\\) and \\(f_2(x) = Q_2(x)\\cdot Z_1(x)\\).\n\nSend Polynomials\n\n(Prover) Sends \\(a(x), b(x), c(x), Q(x), Q_1(x), Q_2(x)\\) to the validator.\n\nVerification (Random Challenge & Single-Point Check)\n\n(Validator) Samples random values \\(\\gamma_1, \\gamma_2, \\gamma_3 \\in \\mathbb{F}_p\\).\n(Valdiator) Computes on its own: \\(t(\\gamma_1), \\quad f_1(\\gamma_2), \\quad f_2(\\gamma_3)\\)\n(Validator) Checks: \\[\nt(\\gamma_1) \\stackrel{?}{=} Q(\\gamma_1)\\,Z(\\gamma_1), \\quad\nf_1(\\gamma_2) \\stackrel{?}{=} Q_1(\\gamma_2)\\,Z_1(\\gamma_2), \\quad\nf_2(\\gamma_3) \\stackrel{?}{=} Q_2(\\gamma_3)\\,Z_1(\\gamma_3).\n\\]\nBy the Schwartz‚ÄìZippel Lemma, if \\(t(x) \\neq Q(x)\\,Z(x)\\) (etc.) the probability it also coincides at a random \\(\\gamma\\) is at most \\(\\frac{d}{p}\\).\n\nAccept or Reject\n\n(Validator) If all checks pass, the proof is accepted; otherwise, it is rejected.\n\n\n\n\nDiagram of Protocol\nBelow is a simplified diagram illustrating these steps:\n\n\n\nWith this approach, the validator does a constant amount of final checks (polynomial evaluations), regardless of the polynomial degree \\(d\\), achieving succinct verification.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>3.Towards a more efficient version</span>"
    ]
  },
  {
    "objectID": "4_An_even_more_efficient_version.html",
    "href": "4_An_even_more_efficient_version.html",
    "title": "4.An even more efficient version",
    "section": "",
    "text": "To put things into perspective, our latest protocol version requires sharing 6 polynomials of degree at most \\(d=3\\) (quotients are typically shorter), and the validator has to still do at most 3 multiplications per each one of the 3 equality checks. That is a communication cost of about \\(3*6\\) field elements and \\(3*3\\) field element multiplications. In general this would be ca. \\(d*6\\) field elements in communication and \\(3*d\\) field multiplications for the \\(d\\)-th Fibonacci number (rounding this to the number of padded rows as discussed before). This does not seem quite useful given that only about \\(d\\) additions would allows us to compute the \\(d\\)-th Fibonacci number directly!\nBut there is a goal behind our strategy. Our goal is to make both the communication and the verification constant (\\(O(1)\\)) for circuits with many gates! To achieve this we need a very useful primitive called a Polynomial Commitment Scheme. In particular, we are going to use the method called KZG. This method relies on pairings over elliptic curves and to keep this notebook as lean as possible, we are preparing a separate tutorial on this topic.\nIn the following we simply recap some fundamental properties of the needed ingredients while keeping our goal on sight.\nWhat do we want to achieve? In a nutshell what we want to achieve is the following: We want to completely delegate computation of the circuit to the processor, and as before, also the interpolation of the column polynomial and the computation of the quotients. But the twist is, we will not ask for a full copy of a given polynomial \\(f(x)\\), but just a very short and constant size piece of information that we call a commitment \\(c_f=\\textsf{commitment}(f(x))\\). With this commitment, we can at a later stage challenge the validator to evaluate \\(f(\\gamma)=\\alpha\\). We will be able to check on our whether indeed \\(f(\\gamma) = \\alpha\\) by using \\(\\gamma, \\alpha\\) and the commitment \\(c_f\\) using a function \\(\\textsf{verify}(\\alpha,\\gamma,c_f)\\).\nWhat this accomplishes:\n\nInstead of sharing a \\(d\\)-size vector for each polynomial over the network, we only share two elements: \\(c_f \\in E\\), where \\(E\\) is an elliptic curve, and \\(\\alpha \\in \\mathbb{F}_p\\).\nA malicious or misbehaving processor \\(P\\) cannot adapt to the interactive challenge \\(\\gamma\\) since it has already commited to a polynomial before seeing the challenge. This gives the validator confidence that the value was correctly computed.\nWe can directly perform the constraint checks \\(f(\\gamma)=Q(\\gamma) \\cdot Z(\\gamma)\\) in constant time, regardless of the number of gates in the circuit (that is, the polynomial \\(d\\) of the interpolating polynomial). Certainly there are some upper bounds to the size of a circuit and we will come back to this later.\n\nGiven that by making this protocol more efficient we have to make it more resilient to misbehaving processors, we are going to call \\(P\\) a prover and \\(V\\) a verifier from now on.\n\nPairings\nThe first ingredient for our new protocol version will be a suitable elliptic curve pairing. We will give you some precomputed functions, but you may reconstruct them on your own.\nWe need a mapping:\n\\[e: \\mathbb{G_1} \\times \\mathbb{G_2} \\to \\mathbb{G_t}\\]\nfor additive cyclic groups \\((\\mathbb{G_1},+)\\) and \\((\\mathbb{G_2},+)\\) and multiplicative \\((\\mathbb{G_t},*)\\). Note that typically the first two groups are additive (since they are subgroups of an elliptic curve) and the destination group is multiplicative (usually defined over a field).\nThe mapping \\(e\\) we are looking for is ‚Äúbilinear‚Äù, that means:\n\\[e(P + P', Q) = e(P,Q)*e(P',Q)\\] \\[e(P,Q+Q')=e(P,Q)*e(P,Q')\\]\nTo construct secure pairings, it is important to chose the groups in a particular way which motivates choosing isomorphic but disjoint \\(\\mathbb{G_1},\\mathbb{G_2}\\) which can be found as subgroups of an elliptic curve over a finite field extension \\(E(\\mathbb{F}_{q^k})\\) and \\(\\mathbb{G_t}\\) a subgroup of \\(\\mathbb{F^*}_{q^k}\\). We are not going to explain this in more depth but if you are curious check Pairings for Beginners by Craig Costello.\n\nimport kzg\ndef e(P,Q):\n    #Base field for BN254\n    q = 21888242871839275222246405745257275088696311157297823662689037894645226208583\n    #Number of points on BN254\n    n = Integer(21888242871839275222246405745257275088548364400416034343698204186575808495617)\n    k = 12\n    t = 6*pow(4965661367192848881,2)+1\n    return P.ate_pairing(Q, n, k, t,q)\n\n\nP = kzg.P\nQ = kzg.Q\n\nshow(\"P:\",P)\nshow(\"Q:\",Q)\nshow(e(P,Q))\n\n\\(\\displaystyle \\verb|P:| \\left(1 : 2 : 1\\right)\\)\n\n\n\\(\\displaystyle \\verb|Q:| \\left(\\left(11559732032986387107991004021392285783925812861821192530917403151452391805634 ubar + 10857046999023057135944570762232829481370756359578518086990519993285655852781\\right) wbar^{2} : \\left(4082367875863433681332203403145435568316851327593401208105741076214120093531 ubar + 8495653923123431417604973247489272438418190587263600148770280649306958101930\\right) wbar^{3} : 1\\right)\\)\n\n\n\\(\\displaystyle \\left(15485169958187804055419367470727586316504614054038886924834910714644298081076 ubar + 14110042394329134992063060126132667374513734777529849604059403292605387766763\\right) wbar^{5} + \\left(17576687079377474679994084448626848766364851367692113922904391421785791556046 ubar + 15263055409656443157285976462204135910932331054849227253916602565546649989931\\right) wbar^{4} + \\left(1451055192040231810539564576166577843622781952620338854414099592814058446945 ubar + 19362144781956138062795090409372908218130916662778620452325203445403259212772\\right) wbar^{3} + \\left(7786695150901409298856750468044088494675441502192568573069643047819302766865 ubar + 16893543948180465298099197784510869270928575391710795413610320310782594693022\\right) wbar^{2} + \\left(8339301614695659949019663159218383351646785965635781625471751346963751888108 ubar + 465898347631256865746797445390333094396673986355153352843254722736295902148\\right) wbar + 15780004297944302906621723394852439600559246581555156000423333429824441348714 ubar + 17296046054077859324401147072502722261136321305912126349272372680482680769943\\)\n\n\nExercise 4 Check that the provided \\(e\\) function is bilinear by randomly sampling an integer \\(s\\) and multiplying over the additive subgroups:\n\\[ e([s]\\cdot P,Q)=e(P,[s] \\cdot Q)=e(P,Q)^s\\]\n\n#Solve here!\ns=\n\n\n\nKZG commitment\nOur goal is to leverage pairings to help provers to commit to a polynomial \\(f(x)\\) before receiving the challenge \\(\\gamma\\) and for the verifier to have (cryptographic) certainty that the evaluation \\(f(\\gamma)\\) was done on this same commited polynomial, ruling out adaptive attacks. There are several answers in the literature to solve this exact problem, one prominent one is the KZG commitment scheme. We can illustrate the protocol with the following sequence diagram.\n\n\n\nFigure 3: The KZG commitment scheme.\n\n\n\nExercise 5 For this protocol to work, we need a trusted setup based on a uniformly random (and secret) toxic waste œÑ. This is called toxic waste since it must be deleted after some setup values have been computed with it in order for the protocol to be secure. We also need to declare a public maximum polynomial degree \\(l\\). Since we will later commit to multiplication of low degree polynomials, let us pick \\(l=10\\).\nWith example \\(\\tau=424242\\), compute two public parameters: a vector \\[S_1 = [  P, \\tau \\cdot P , \\tau^2 \\cdot P , \\cdots,  \\tau^{l} \\cdot P]\\]\nwhere \\(P\\) is the generator of \\(\\mathbb{G}_1\\) and a value \\[S_2 = \\tau \\cdot Q\\] where \\(Q\\) is the generator of the group \\(\\mathbb{G}_2\\).\n\n#Solve here!\nœÑ = 424242\nl=10\nS1=\nS2=\n\nIf computed correctly you should get:\n\\[\n\\begin{aligned}\nS_1 = \\Big[ &\\left(1 : 2 : 1\\right), \\\\\n&\\left(3388106087484702502772161951837520865682365219266094058038991331506090320735 : 10310862820936104897688292475187545406556140958479334534497508049176340462168 : 1\\right), \\\\\n&\\left(5786299459695789788261684662131390109566181344091061986154006773045920884529 : 18198083969462810098554436542449595852850793038741994323649111219383738839374 : 1\\right), \\\\\n&\\left(5932386722799341949736906223819928737327798404444018663115122905353930163217 : 17316789122660091087982740003020863959605853926224865905583913597777031548221 : 1\\right), \\\\\n&\\left(14603143723753528702641274659350642057392810682423113693594196367092666272615 : 17734357240639322091230265203514580412414342326449923671483947891721675198742 : 1\\right), \\\\\n&\\left(1485870938289488242176031429247482114928668541241910486620153058173498550422 : 8975504733770431670587733015492501696212039808343155103983507429794936273090 : 1\\right), \\\\\n&\\left(35087711382470900519387874116184362249603265567233267930080986182721755391 : 9687295787051875541592859447450503637855174457649076441192556983747473888473 : 1\\right), \\\\\n&\\left(21100087779353388367643433264506322944085867030119306347233967681812330825611 : 17068231115940713163151138839050846284784298672314356795840059410045954257490 : 1\\right), \\\\\n&\\left(10641104735982477671491147382199353108251699282959504595440637553392719424596 : 3033897669229592557681916129851961240665115699542840722127903032620063452401 : 1\\right), \\\\\n&\\left(12461517031230393262909098092888598630825065680164551109453025306556394017248 : 11406184524960241674372900569663181593279300027508257400554857135388045542548 : 1\\right), \\\\\n&\\left(2310703006113265329769149621286389443406062880925858119855767049953176497692 : 20254007398902051444166009223523085479917136359422165955249757385592434525697 : 1\\right)\n\\Big]\n\\end{aligned}\n\\]\nand:\n\\[\n\\begin{aligned}\nS_2 = \\big( &\n\\big(18178798121214140434976027337622332703345638858169149597321922257824015358086\\, \\bar{u} + \\\\\n&\\quad 17892288729126503148648989889095246645011224085306750203724686651395006961383\\big) \\bar{w}^2 \\; : \\\\\n&\\big(15251007341879318938631029793693405432107362852215428951388705343135014132495\\, \\bar{u} + \\\\\n&\\quad 11565079700697045165214936027269859661189920603201791930010463312628382919842\\big) \\bar{w}^3 \\; : \\\\\n&1\n\\big)\n\\end{aligned}\n\\]\n\n\n\n\nExercise 6 Implement a commitment function. This function takes as parameters the public vector \\(S_1\\) we computed before and the polynomial \\(p(x)\\) we want to commit to. It then computes \\[\\sum_{i=0}^{l} a_i \\cdot S_1[i] \\]\nNote that by construction this is:\n\\[a_0 \\cdot P + a_1 \\cdot \\tau \\cdot P + a_2 \\cdot \\tau^2 \\cdot P  + \\cdots + a_{l} \\cdot \\tau^{l} \\cdot P \\]\nwhich is equivalent to:\n\\[p(\\tau) \\cdot P\\]\nNote that this will be a point on the curve \\(EK\\). Test your function over the polynomial \\(a(x)\\) of the Fibonacci example.\n\ndef commitment(S1,p):\n    #Solve here!\n    return c\n\nc = \n\nIf computed correctly, you should get a commitment:\n\\[\n\\begin{aligned}\nc = \\big( &\n19772988533509128204934208855583299243034568734268587639600165428945857082832 \\; : \\\\\n&21198549198844316278609987090510616007059968516882705878791833422348082226388 \\; : \\\\\n&1 \\big)\n\\end{aligned}\n\\]\nNow this commitment \\(c\\) can be given to the verifier before any challenge is issued.\n\n\n\nIn a subsequent step, the prover will receive the challenge \\(\\gamma\\) from the verifier. They will now give back \\(f(\\gamma)\\) but this time also a proof \\(\\pi\\) that indeed this is the evaluation of \\(\\gamma\\) in the very same polynomial that the prover commited to through \\(c\\).\nExercise 7 The \\(\\textsf{proof}\\) generating function receives two parameters, the vector \\(S_1\\) and a polynomial \\(Q_c\\). Similar as before, this will compute a point on the curve which is equal to:\n\\[\\pi = b_0 \\cdot P + b_1 \\cdot \\tau \\cdot P + b_2 \\cdot \\tau^2 \\cdot P + \\cdots + b_{l} \\cdot \\tau^{l} \\cdot P = Q_c(\\tau) \\cdot P\\]\nwhere \\(b_i\\) are the coefficients of the polynomial \\(Q_c\\). Now, the way this polynomial is constructed is essential for the proof:\n\\[Q_c(x) = \\frac{f(x) - f(\\gamma)}{x-\\gamma} \\]\nAgain here we are exploiting the fact that \\(\\gamma\\) is a root of \\(f(x) - f(\\gamma)\\) therefore this polynomial must be divisible by \\(x-\\gamma\\). Compute the \\(\\texttt{proof}\\) function and test it on the \\(Q_c\\) polynomial for the challenge \\(\\gamma = 151515\\) and the polynomial \\(a(x)\\).\n\ndef proof(S1,Qc):\n    #Solve here!\n    return c\n\n#Given a challenge Œ≥\nŒ≥ = 151515\n#Solve here!\nb = \nQc= \nœÄ = \n\nIf computed correctly, the proof obtained from \\(\\texttt{proof}\\) when called on \\(Q_c\\) should be:\n\\[\n\\begin{aligned}\n\\pi = \\big( &\n18427764633036746853571353448280965399000717707037995558464363091930831203059 \\; : \\\\\n&15823869948268955546174436172082876809321127559750802916163692992123652869945 \\; : \\\\\n&1 \\big)\n\\end{aligned}\n\\]\nThe value of the polynomial on the challenge point is:\n\\[a(\\gamma) = 1739069066686765\\]\n\n\n\nSo now the prover, who has issued the challenge \\(\\gamma\\), has both \\(c\\) and \\(\\pi\\). He will use the verification function that takes as parameters \\(c, \\pi, \\gamma\\) and \\(b=f(\\gamma)\\). We are finally ready to use the pairing. We want to check whether the following values are equal.\n\\[\n{e(\\pi, S_2 - \\gamma \\cdot Q)} \\stackrel{?}{=} {e(c- b \\cdot P, Q)}\n\\]\nThe left-hand side is:\n\\[\n{e(\\pi, S_2 - \\gamma \\cdot Q)} = e( Q_c(\\tau) \\cdot P, (\\tau - \\gamma) \\cdot Q)\n\\]\nand using bilinearity:\n\\[\ne( Q_c(\\tau) \\cdot P, (\\tau - \\gamma) \\cdot Q) = e( {Q_c(\\tau)\\cdot (\\tau - \\gamma)} \\cdot P,  Q)\n\\]\nThe right-hand side is:\n\\[\n{e(c- b \\cdot P, Q)} = e(f(\\tau) \\cdot P - f(\\gamma) \\cdot P, Q) = e( {(f(\\tau) - f(\\gamma))} \\cdot P, Q)\n\\]\nSo essentially what the pairing allows us to do is to check:\n\\[\n{f(\\tau) - f(\\gamma)} \\stackrel{?}{=} {Q_c(\\tau)\\cdot (\\tau - \\gamma)}\n\\]\nwhich is expected by the construction of \\(Q_c\\). This is equivalent to checking polynomial equality using the challenge \\(\\tau\\). But remember, nobody knows \\(\\tau\\) directly because we deleted it after setup (‚Äútoxic waste‚Äù)!\nExercise 8 Implement a \\(\\textsf{verification}\\) function that takes \\(c,\\pi,\\gamma\\) and \\(f(\\gamma)=b\\) as parameters. It should output true or false, by evaluating:\n\\[{e(\\pi, S_2 - \\gamma \\cdot Q)} \\stackrel{?}{=} {e(c- b \\cdot P, Q)}\n\\]\nTest the function on the previously computed commitment \\(c\\) for \\(a(x)\\) and the proof \\(\\pi\\) computed in the previous exercise.\n\ndef verification(c,œÄ,Œ≥,b):\n    #Solve here!\n    \nprint(verification(c,œÄ,Œ≥,b)) #should return True\n\n\n\nNew Protocol Version\nWe divide the protocol into Setup, Prover Computation, Verifier Challenge, and Proof & Verification phases.\n\n\n1. Setup Phase\n\n(Both) Agree on the public parameters \\((S_1, S_2)\\).\n(Verifier) Publicly specifies the maximum polynomial degree \\(d\\), if needed.\n(Trusted Ceremony / Setup) Generates a secret \\(\\tau\\) and produces \\((S_1, S_2)\\).\nAfter this step, \\(\\tau\\) (the toxic waste) must be discarded to maintain security.\n\n\n\n2. Prover Computation Phase\n\n(Prover) Interpolates the column polynomials \\(a(x), b(x), c(x)\\).\n(Prover) Constructs quotient polynomials \\(Q(x), Q_1(x), Q_2(x)\\) with respect to the vanishing polynomials \\(Z(x), Z_1(x)\\).\n(Prover) Commits to each polynomial by computing \\[\nc_a = \\text{commit}(a), \\quad\nc_b = \\text{commit}(b), \\quad\nc_c = \\text{commit}(c), \\quad\nc_Q = \\text{commit}(Q), \\quad \\dots\n\\] and sends these commitments to the Verifier.\n\n\n\n3. Verifier Challenge Phase\n\n(Verifier) Samples random challenges \\(\\gamma_1, \\gamma_2, \\gamma_3\\).\n(Verifier) Sends the challenges to the Prover.\n\n\n\n4. Proof & Verification Phase\n\n(Prover) Evaluates each committed polynomial at its corresponding challenge. For example, \\[\na(\\gamma_1), \\quad b(\\gamma_1), \\quad c(\\gamma_1), \\quad Q(\\gamma_1).\n\\] Then constructs proofs \\(\\pi_a, \\pi_b, \\pi_c, \\pi_Q\\) via the KZG evaluation method. The Prover sends \\[\n\\bigl(a(\\gamma_1),\\,b(\\gamma_1),\\,c(\\gamma_1),\\,Q(\\gamma_1)\\bigr)\n\\] and \\[\n(\\pi_a,\\,\\pi_b,\\,\\pi_c,\\,\\pi_Q)\n\\] to the Verifier.\n(Verifier) Uses the commitments \\((c_a,\\,c_b,\\,c_c,\\,c_Q)\\) and the proofs \\(\\pi_a, \\pi_b, \\pi_c, \\pi_Q\\) to verify each polynomial evaluation.\nIt then checks the constraint \\[\na(\\gamma_1) + b(\\gamma_1) - c(\\gamma_1)\n  \\;=\\; Q(\\gamma_1)\\,\\cdot Z(\\gamma_1).\n\\] Since the Verifier can construct \\(Z(x)\\) itself, it only needs to check \\(t(\\gamma_1) = Q(\\gamma_1)\\,Z(\\gamma_1)\\), where \\(t(x)= qL(x) \\cdot a(x) + qR(x) \\cdot b(x) + qM(x) \\cdot (a(x) \\cdot b(x)) - c(x)\\).\n(Verifier) Repeats a similar check for the recursive constraints: \\[\na(\\gamma_2 + 1) \\;-\\; b(\\gamma_2) \\;=\\; Q_1(\\gamma_2)\\,\\cdot Z_1(\\gamma_2),\n\\] \\[\nb(\\gamma_3 + 1) \\;-\\; c(\\gamma_3) \\;=\\; Q_2(\\gamma_3)\\,\\cdot Z_1(\\gamma_3).\n\\]\n(Verifier) If all these checks pass, the Verifier accepts. Otherwise, it rejects.\n\nAs you can see, both the number of message exchanges and the operations performed by the Verifier are now almost constant. In other words, the Verifier can ask the Prover to compute \\(F_6\\) or \\(F_{1000}\\) and still carry out about the same number of computations. The only operation dependent on the number of rows of the circuit on the verifier‚Äôs side is the computation of the vanishing polynomials \\(Z\\) and \\(Z_1\\).\n\n\nProtocol Diagram\nThe following diagram visually represents the four main phases of the protocol:\n\nPhase 1: Setup\n\nBoth parties agree on the public parameters \\((S_1, S_2)\\).\n\nThe Verifier may specify the maximum polynomial degree \\(d\\).\n\nA trusted ceremony generates the secret \\(\\tau\\), then discards it, while producing the public parameters \\((S_1, S_2)\\).\n\nPhase 2: Prover Computation\n\nThe Prover interpolates the circuit columns (e.g., Fibonacci) into polynomials \\(a(x), b(x), c(x)\\).\n\nConstructs the quotient polynomials \\(Q(x), Q_1(x), Q_2(x)\\) relative to vanishing polynomials \\(Z, Z_1\\).\n\nCommits to these polynomials (e.g., \\(c_a, c_b, c_c, c_Q, \\dots\\)) and sends the commitments to the Verifier.\n\nPhase 3: Verifier Challenge\n\nThe Verifier randomly samples challenges \\(\\gamma_1, \\gamma_2, \\gamma_3\\).\n\nSends these challenges to the Prover.\n\nPhase 4: Proof & Verification\n\nThe Prover evaluates each committed polynomial at the corresponding \\(\\gamma\\) value and constructs proofs (e.g., \\(\\pi_a, \\pi_b\\)).\n\nSends the polynomial evaluations and proofs to the Verifier.\n\nThe Verifier checks that the evaluations match the commitments, confirming equations like \\[\nt(\\gamma_1) \\;=\\; Q(\\gamma_1) \\cdot Z(\\gamma_1).\n\\]\nIf all checks pass, the Verifier accepts; otherwise, it rejects.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>4.An even more efficient version</span>"
    ]
  },
  {
    "objectID": "5_Domains.html",
    "href": "5_Domains.html",
    "title": "5.Domains",
    "section": "",
    "text": "Note that so far we have exploited a convenient structure to verify the correctness of a computation: that of evaluating polynomials on a set of points (or indexes) \\(I\\) and checking constraints by means of quotient polynomials. This way we could almost bring the computational time of the verifier to a constant. But there is a catch: computing the vanishing polynomials \\(Z\\) and \\(Z_1\\) as the multiplication of \\((x-i)\\) monomials, although not a very expensive operation is still dependent on the number of rows of the circuit (which corresponds to the maximum polynomial degree \\(d\\)). Also, the way we check constraints \\(f_1\\) and \\(f_2\\), by comparing values in a given row with the next row, and by considering a different index set \\(I' = I \\setminus{\\{3,4\\}}\\) is not very general. What if we want to evaluate a circuit where connections between gates are different, do we have to define a new polynomial for each constraint by hand and carefully think about which domain to evaluate?\nTo address this issues, and to improve efficiency even more, let us introduce a different type of indexing: using a multiplicative subgroup (also referred to commonly as a domain). A particularly interesting set of domains are the ones with size \\(n=2^k\\). Mathematically we want to find a set of points \\(\\Omega \\in \\mathbb{F}_p\\) such that:\n\\[\\Omega = \\{ \\omega, \\omega^2, \\dots, \\omega^{2^k-1},1 \\}\\]\nfor some generator \\(\\omega \\in \\mathbb{F}_p\\). This set will replace our previous set of indexes \\(I\\). One immediate advantage of this choice is that computing the vanishing polynomial for the domain can be done in constant time, because \\(Z = x^n - 1\\), and we no longer need to multiply each monomial \\((x-i)\\) as we did with the additive indexes. This follows immediately from the definition of \\(\\Omega\\) given that each element is a so-called ‚Äú\\(n\\)-root of unity‚Äù, a field element of order \\(n\\): for every \\(\\omega^i \\in \\Omega\\), it holds \\((\\omega^i)^n = (\\omega^n)^i = 1^i = 1\\).\nExercise 9 Find a generator \\(\\omega\\) of a domain of order \\(4\\) using the following algorithm. Consider \\(r = (p-1)/4\\). Find the smallest \\(h \\in \\mathbb{F}_p\\) such that \\(\\omega=h^r\\) has multiplicative order \\(4\\). In other words, \\(\\omega^4 = 1\\) and \\(\\omega^i \\neq 1\\) for \\(i \\in \\{1,2,3,4\\}\\).\n\nn = pow(2,2)\n\n#Solve here!\nr = \nh = \nœâ = \n\n\nIf computed correctly you should obtain:\n\\[\\omega = 21888242871839275217838484774961031246007050428528088939761107053157389710902\n\\]\nNote that a further interesting property of working with multiplicative indexes is that they ‚Äúwrap around‚Äù, that is, whenever we go beyond the order of the multiplicative group, we cycle back to the beginning of the group: \\(\\omega^0 = \\omega^n = 1\\). We will benefit from this property in the next section, were we generalize wiring constraints.\nExercise 10 Interpolate the value vectors and selector vectors as before, now over \\(\\Omega\\) instead of \\(I\\).\n\n#Solve here! Hint: your previously defined interpolate function should also work here!\nŒ© = \na = \nb = \nc = \n\nqL =\nqR =\nqM =\n\nIf computed correctly you should have obtained:\n\\[\n\\begin{aligned}\na(x) =\\;& 16416182153879456417786784551517017277046601793284012108757927423286461067892\\, x^{3} \\\\\n      +\\;& 5472060717959818805561601436314318772137091100104008585924551046643952123905\\, x^{2} \\\\\n      +\\;& 5472060717959818804459621193740257811501762607132022234940276763289347427726\\, x \\\\\n      +\\;& 16416182153879456416684804308942956316411273300312025757773653139931856371714\n\\end{aligned}\n\\]\nWe said that one of the advantage of working with multiplicatives domains is that the verifier can now use \\(Z(x)=x^n-1\\) as the vanishing polynomial, which can be computed in constant time, instead of \\(Z(x)=\\prod_i^d (x-i)\\) which is an \\(O(d)\\) operation.\nExercise¬†11 Let \\(t(x) \\;=\\; qM*a*b + qL*a+qR*b-c\\) where the polynomials¬†\\(a(x),\\,b(x),\\,c(x)\\) are obtained by Lagrange‚Äìinterpolating the three witness columns over the multiplicative domain \\(\\Omega \\;=\\; \\{\\omega,\\; \\omega^{2}, \\dots, \\omega^{4}\\,\\}\\). Take the domain‚Äëvanishing polynomial \\(Z(x) \\;=\\; x^{4} - 1\\). Perform polynomial long‚Äëdivision of¬†\\(t(x)\\) by¬†\\(Z(x)\\); that is, find polynomials¬†\\(Q(x),\\,R(x) \\in \\mathbb{F}_{p}[x]\\) such that:\n\\[t(x) = Q(x) \\cdot Z(x) + R(x)\\]\nVerify that the division is exact: show that the remainder¬†\\(R(x)\\) is zero. Equivalently, confirm that there exists a polynomial \\(Q(x) \\in \\mathbb{F}_{p}[x]\\) for which\n\\[t(x) \\;=\\; Q(x) \\cdot Z(x)\\]\n\n#Solve here!\n\nt = \nZ =                      \nQuo=\nRem=\n\nprint(\"Quotient Q(x):\\n\", Quo)\nprint(\"\\nRemainder R(x):\\n\", Rem)\nprint(\"\\nIs remainder zero?  \", Rem == 0) #should be True",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>5.Domains</span>"
    ]
  },
  {
    "objectID": "6_Copy_constraints.html",
    "href": "6_Copy_constraints.html",
    "title": "6.Copy constraints",
    "section": "",
    "text": "Recall our discussion on the recursive constraints \\(f_1,f_2,f_3\\) and \\(f_4\\) for our squared Fibonacci example. What we wanted to achieve essentially was to ensure that some values (input or output) in a previous row were re-used in a subsequent row. This is nothing else than what is commonly known as the ‚Äúwiring‚Äù of a circuit: an input wire may be linked to multiple gates, or the output wire of a gate can be the input of another. Mathematically we can think of wiring as a partition of positions in the table representing the circuit into equivalence classes (defined by equality). Consider the following image. Here we can see the 4 partitions as different colors both on the table and on the circuit.\n\n\n\nExercise 12: Compute an array encoding a permutation over the three columns \\(a,b,c\\). That is, compute a mapping from \\(1,2,\\cdots, 12\\) to \\(1,2,\\cdots, 12\\) that encodes the equivalence relation of the wiring between the three columns. For example \\(2 \\to 5\\) and \\(5 \\to 2\\) because 5 is the first position (\\((4+1)\\)) of the second column.\n\nsigma = {}\n#First input\nsigma[1] = 1\n\n#First cycle\nsigma[2] = 5\nsigma[5] = 2\n\n#Solve here!\n\nIf implemented correctly, your permutation should pass the following checks.\n\nprint(\"Length should be 12:\", len(sigma) == 12)\nprint(\"There should be no repeated elements in the domain:\", len(set(sigma.keys())) == 12 ) \nprint(\"Both the image and domain should be the indexes from 1 to 12\", set(sigma.keys()) == set(range(1,13)) == set(sigma.values()))\nprint(\"The cycle (3,4+2,8+1) should be in sigma:\" , sigma[3] == 4+2 and sigma[4+2] == 8+1 and sigma[8+1] == 3)\n\nLength should be 12: True\nThere should be no repeated elements in the domain: True\nBoth the image and domain should be the indexes from 1 to 12 True\nThe cycle (3,4+2,8+1) should be in sigma: True\n\n\nThe mathematical property we want to check for a given function \\(f: I \\to \\mathbb{F}\\) is the following:\n\\[\\forall i \\in I: f(i)= f(\\sigma(i))\\]\nIf this holds, we know that all values in our equivalence classes are equal. We can in fact check this for our permutation \\(\\sigma\\) and our three columns \\(a,b,c\\) as follows.\n\ncolumns = [a, b, c]\nfor col in range(3):\n    for i in range(1, n+1):                      # rows 1‚Ä¶n\n        slot = col*n + i                         # ‚Äúflattened‚Äù slot in 1‚Ä¶3n\n        mapped = sigma[slot]                     # in 1‚Ä¶3n\n\n        # convert to 0-based so divmod works nicely\n        zero_slot = mapped - 1                   \n        col2, idx2_zero = divmod(zero_slot, n)   # col2 in 0..2, idx2_zero in 0..n-1\n        i2 = idx2_zero + 1                       # back to 1‚Ä¶n indexing\n        \n        x1 = œâ**(i )\n        x2 = œâ**(i2 )\n\n        assert columns[col](x1) == columns[col2](x2), \"Permutation property does not hold\"\n            \n\nNow the question is, how does the prover convince the verifier that this holds without sharing all intermediate computation values?\nOne simple way to achieve this is to run the equality testing protocol for:\n\\[ f \\circ \\sigma - f = 0 \\]\nover the domain \\(\\Omega\\) and an interpolated version of \\(\\sigma\\). Unfortunately, this solution is inefficient since the composition of two polynomials of degree \\(n\\) has degree of about \\(n^2\\). For instance if we compose \\(a\\) and \\(b\\) we obtain a polynomial of degree 9 (why?):\n\na(b)\n\n21802741923121153053822748313780136717971970536841404091162235932729973504748*x^9 + 17698696384651288949806513208156374961458495281087583232325986218843750697220*x^8 + 15219168871825746054207931767645017665721029176757758524459966167252422127810*x^7 + 13851153692335791356915520435638727170049384234971330620701598396816370310749*x^6 + 15732174564134479069295544857125849351800122391714983737485907109165176444762*x^5 + 6156068307704796159975984934541064360798461151397463593737045633796236988998*x^4 + 21717240974403030896832135899008880813987109787851132230088113368688162236738*x^3 + 12141134717973347974460997478437561320460776708896648741869253349838123410604*x^2 + 13081645153872691828051025054357947332337167624162695003407885568722756022565*x + 15817675512852601238803964089886828980501917740558913054272020360688200433438\n\n\nInstead, we are going to introduce a new protocol to approach this check in an efficient way. Fundamentally, what we want to do is to capture the ‚Äúfor all‚Äù quantifier where we check \\(f(\\sigma(i))\\) with \\(f(i)\\) using a product, in a way that we avoid computing the costly polynomial composition.\nTo motivate the concrete algorithm, consider the following. Assume \\(h\\) is a cryptographically secure hash function. If we compute\n\\[GP = \\prod_{i=1}^n \\frac{h(i,f(i))}{h(i,f(\\sigma(i)))}\\]\nwe expect to be \\(GP=1\\) if and only if \\(f(\\sigma(i))=f(i)\\). One direction is easy to see, for the other one we would conclude that either there was a hash collision or some unlikely scenario arises (details are left as an exercise).\nOne useful observation is that we can write the \\(GP\\) alternatively like this:\n\\[GP = \\prod_{i=1}^n \\frac{h(i,f(i))}{h(i,f(\\sigma(i)))} = \\prod_{i=1}^n \\frac{h(i,f(i))}{h(\\sigma(i),f(i))} \\]\nbecause the values are in the equivalence class defined by \\(\\sigma\\). In fact, the numerator is exactly the same, and the denominator as well: noticed that on the original denominator we had \\(h(\\sigma(i), f(\\sigma(i))\\) which, if the permutation holds, is equal to \\(h(\\sigma(i),f(i)\\). But the advantage of this equivalent representation is that we do not have to explicitely compose the polynomial \\(f\\) with \\(\\sigma\\).\nNow, in practice we want to have an efficient ‚Äúhash‚Äù function that has the same security properties as before, such that \\(GP=1\\) implies (with high probability) that the permutation property holds. For this we consider the class of functions:\n\\[h(i,f(i)) = i + \\beta \\cdot f(i) + \\gamma\\]\nfor random interactive challenges \\(\\beta\\) and \\(\\gamma\\). It is possible to show using Schwartz-Zippel that those will behave similar to the cryptographic hash function in our discussion above, but they are efficiently computable (for more details see the original paper).\nWe will now step by step construct the argument that takes advantage of this. First we start by defining a numerator and denominator functions, and their respective accumulators.\nExercise 13 Compute the numerator using the formula \\[ (column - 1) \\cdot n + i + \\beta\\cdot f(\\omega^i) + \\gamma\\] and the denominator as \\[\\sigma(column - 1) \\cdot n + i + \\beta\\cdot f(\\omega^i) + \\gamma\\]\n\ndef numerator(i, column,f,sigma,beta, gamma):\n#Solve here!    \n    return value    \n\ndef denominator(i, column,f,sigma,beta, gamma):\n#Solve here!\n    return value       \n\n\n\n#Test cases\nnumerator(3,1,a,sigma,42,42) == 87\ndenominator(3,1,a,sigma,42,42) == 90\n\nnumerator(6,2,b,sigma,42,42) == 94\ndenominator(6,2,b,sigma,42,42) == 91\n\nTrue\n\n\nExercise 14 Compute accumulator functions for the numerator and the accumulator respectively as:\n\\[ \\textsf{acc\\_numerator}(i, column,f,\\sigma,\\beta, \\gamma) = \\prod_{j=1}^{i-1} \\textsf{numerator}(j, column,f,\\sigma,\\beta, \\gamma)\\] \\[ \\textsf{acc\\_denominator}(i, column,f,\\sigma,\\beta, \\gamma) = \\prod_{j=1}^{i-1} \\textsf{denominator}(j, column,f,\\sigma,\\beta, \\gamma)\\]\n\ndef acc_numerator(i, column,f,sigma,beta, gamma):\n    value = 1 \n    #Solve here!\n    return value    \n\ndef acc_denominator(i, column,f,sigma,beta, gamma):\n    value = 1 \n    #Solve here!\n    return value        \n\nIf implemented correctly, the following check should pass.\n\nN_n = acc_numerator(n+1,1,a,sigma,42,42)*acc_numerator(n+1,2,b,sigma,42,42)*acc_numerator(n+1,3,c,sigma,42,42)\nD_n = acc_denominator(n+1,1,a,sigma,42,42)*acc_denominator(n+1,2,b,sigma,42,42)*acc_denominator(n+1,3,c,sigma,42,42)\nprint(\"When multiplying z for each column with the corresponding upper and lower bounds one should obtain 1:\", N_n//D_n==1)  \n\nWhen multiplying z for each column with the corresponding upper and lower bounds one should obtain 1: True\n\n\nNow that we have both the numerator and denominator functions, and the partial accumulators we can proceed to spell out the interactive protocol that allows the (potentially malicious) prover to prove that the permutation holds over the three columns \\(a\\),\\(b\\),\\(c\\) in an efficient way. Note that the following function has an interesting property, which is that it can be defined recursively:\n\\[z(i+1)= \\frac{\\mathsf{acc\\_numerator}(i+1)}{\\mathsf{acc\\_denominator}(i+1)} = z(i) \\cdot \\frac{\\mathsf{numerator}(i)}{\\mathsf{denominator}(i)}\\]\nMoreover, the base case is \\(z(1)=1\\). We would like also to be able to prove that \\(z(n+1)=1\\), given that this represents the grand product argument when considering all indexes.\nWe can develop a succinct argument using polynomials by following these steps:\n\nWe assume the prover has already commited to \\(a,b,c\\).\nThe verifier challenges the prover with random \\(\\beta\\) and \\(\\gamma \\in \\mathbb{F}_p\\).\nThe prover interpolates \\(z\\) over \\(\\Omega\\) by computing each of the points for \\(i=1, \\dots, n\\).\nThe prover interpolates polynomials \\(N\\) and \\(D\\) corresponding to the \\(\\mathsf{numerator}\\) and \\(\\mathsf{denominator}\\) functions.\nThe prover computes the quotient polynomial \\(Q_z\\) for the polynomial \\(z\\cdot N -D\\cdot z(x \\cdot œâ)\\) and commits to it.\nThe verifier checks the following two properties\n\n\\(z(\\omega)=1\\)\n\\(z\\cdot N -D\\cdot z(x \\cdot œâ)=0\\)\n\n\nIt is interesting to note that in the multiplicative domain, \\(z(\\omega)=1\\) automatically implies \\(z(\\omega^{n+1})=1\\). This follows from:\n\\[z(\\omega^{n+1})=z(\\omega^n \\cdot \\omega) = z(\\omega) =1 \\]\nExercise 15 Compute a function that receives as parameters the three polynomials \\(a,b,c\\) , the challenges \\(\\beta, \\gamma\\) and the domain \\(\\Omega\\) and returns the interpolation fo the \\(z\\), \\(N\\) and \\(D\\) polynomials.\n\ndef interpolate_z_N_D(a,b,c, beta, gamma, Œ©):\n#TBD\n    return z,N,D\n\nz,N,D = interpolate_z_N_D(a,b,c,42,42,Œ©)\n\nIf computed correctly, the interpolated functions should pass the \\(z(\\omega)=1\\) check as follows.\n\nL1 = prod((x - œâ**m)//(œâ - œâ**m) for m in range(2,n+1))\nL1=R(L1)\nZH = R(x^n-1)\n(ZH).divides(L1*(z-1))\n\nTrue\n\n\nMoreover it should pass the following check, which proves the recursive constraint.\n\n(ZH).divides( z*N -D*z(x*œâ))\n\nTrue\n\n\nThe polynomial \\(z(x) \\cdot N(x) -D(x) \\cdot z(x*œâ)\\) is:\n\\[\n\\begin{aligned}\nz(x) \\cdot N(x) - D(x) \\cdot z(x \\cdot \\omega) =\\;&\n19088033315219631021107812019832839306780395371633216223270161982137379434783\\, x^{6} \\\\\n&+ 9442345120481651903520919226899454023736002770233426083846080860317389062734\\, x^{5} \\\\\n&+ 21082329243894486516657209903907612685168280090308035096051805040844722189074\\, x^{4} \\\\\n&+ 2800209556619644201138593725424435781767969028782818120428042204438429060834\\, x^{2} \\\\\n&+ 12445897751357623318725486518357821064812361630182608259852123326258419432883\\, x \\\\\n&+ 805913627944788705589195841349662403380084310107999247646399145731086306543\n\\end{aligned}\n\\]\n\nshow(z*N -D*z(x*œâ))\n\n\\(\\displaystyle 19088033315219631021107812019832839306780395371633216223270161982137379434783 x^{6} + 9442345120481651903520919226899454023736002770233426083846080860317389062734 x^{5} + 21082329243894486516657209903907612685168280090308035096051805040844722189074 x^{4} + 2800209556619644201138593725424435781767969028782818120428042204438429060834 x^{2} + 12445897751357623318725486518357821064812361630182608259852123326258419432883 x + 805913627944788705589195841349662403380084310107999247646399145731086306543\\)",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>6.Copy constraints</span>"
    ]
  },
  {
    "objectID": "7_Towards_ZKP.html",
    "href": "7_Towards_ZKP.html",
    "title": "7.Towards ZKP",
    "section": "",
    "text": "Note that although we have focused on a malicious prover so far, the verifier may deviate from the honest protocol to learn secret data from the verifier. For example, they can choose adaptive off-domain points or collude across multiple openings with the goal of extracting intermediate witness values or private inputs.\n\nBlinding via vanishing-polynomial multiples\nTo defend against this, we mask each witness polynomial (f(x)) by adding a random multiple of the vanishing polynomial. \\[Z_H(x) \\;=\\; x^n - 1.\\]\nConcretely, before committing we form\n\\[\\widetilde f(x) \\;=\\; f(x)\\;+\\;Z_H(x)\\cdot p(x),\\]\nwhere \\(p(x)\\) is drawn uniformly at random from all polynomials of degree \\(&lt;k\\) (for some security parameter \\(k\\).\n\n\nOne fresh blinding factor per opening\nEach time the verifier opens \\(\\widetilde f\\) at a point \\(z\\not\\in\\{\\omega^i\\}\\), they learn\n\\[\\widetilde f(z) \\;=\\; f(z)\\;+\\;Z_H(z)\\cdot p(z)\\]\nwhich yields one linear equation in the coefficients of \\(p(x)\\).\n- If the same \\(p(x)\\) were reused for multiple openings, a malicious verifier could gather enough of these equations to solve for \\(p(x)\\), then subtract \\(Z_H(x)\\cdot p(x)\\) and recover the original \\(f(x)\\).\n- To preserve zero-knowledge, we therefore allocate one independent random polynomial \\(p(x)\\) for each distinct off-domain opening query.\nExample Consider the following example for blinding the witness polynomial \\(a(x)\\). We assume two openings on \\(a(x)\\), as we will see later in the full protocol.\n\nk = 2\n\np = R.random_element(degree=k-1)\nprint(\"p(x) =\", p)\na_blind = a + p*ZH\nshow(a_blind)\nprint(\"Degree of a_blind:\",a_blind.degree())\n\np(x) = 7846974345743743743009628096037841263957128127461006184358032298078777836753*x + 17400493923130958490506171015032528352276895896363983356660864143955303261126\n\n\n\\(\\displaystyle 7846974345743743743009628096037841263957128127461006184358032298078777836753 x^{5} + 17400493923130958490506171015032528352276895896363983356660864143955303261126 x^{4} + 16416182153879456417786784551517017277046601793284012108757927423286461067892 x^{3} + 5472060717959818805561601436314318772137091100104008585924551046643952123905 x^{2} + 19513329244055350283696398842959691636092998880087050394280448651786378086590 x + 20903931102587773148425039039167703052682741804364076744810993182552361606205\\)\n\n\nDegree of a_blind: 5\n\n\nExercise 16 Assuming \\(b(x),c(x)\\) also have at most two openings, blind them similarly to \\(a(x)\\). Afterwards, interpolate \\(z\\_poly, N\\_poly, D\\_poly\\) using the given \\(\\beta\\) and \\(\\gamma\\). Finally blind \\(z\\_poly\\) assuming also at most 2 openings.\n\nbeta = gamma = 42\n\nb_blind = #?\nc_blind = #?\nz_poly = #?\nN_poly = #?\nD_poly = #?\nz_poly_blind = #?\n\nIf computed correctly the following check should still pass on the blinded polynomials, because the roots of the polynomial do not change (points of the domain).\n\nassert (ZH).divides( z_poly_blind*N_poly -D_poly*z_poly_blind(x*œâ)) == True, \"Something went wrong\"",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>7.Towards ZKP</span>"
    ]
  },
  {
    "objectID": "8_Fiat_Shamir.html",
    "href": "8_Fiat_Shamir.html",
    "title": "8.Fiat Shamir",
    "section": "",
    "text": "Verifier\nNow let‚Äôs put all the pieces together.\nIn practice, we often want a non-interactive proof system so that we can compute the proofs at one point in time on a given machine, and check them later when needed. To achieve this, we use the Fiat-Shamir transformation, where we assume a hash function behaves as a random oracle. The idea is that the prover himself can generate ‚Äúunbiased‚Äù challenges based on the messages he would send to the verifier in an interactive version of the protocol by using a hash function. See for instance the following two functions that operate over a string that we will call a ‚Äútranscript‚Äù.\nThe first function \\(\\textsf{push}\\) adds values to the transcript (field elements, curve elements) by using delimiters to separate them. The \\(\\textsf{generate\\_challenge}\\) function will hash a given transcript and create an element in \\(\\mathbb{F}\\) from the hash.\nStep 1 We start with an empty transcript and add the initial values \\(a(\\omega)\\) and \\(b(\\omega)\\) which should be \\(0\\) and \\(1\\) to the transcript, as well as the output \\(c(\\omega^4)\\) which should be 9. We also add commitments to the blinded polynomials \\(a\\_blind, b\\_blind, c\\_blind\\).\nExercise 17 Push the values discussed above in order to the empty transcript. Also compute proofs for the openings of \\(a,b,c\\) corresponding to the inputs and output. Proofs are not added to the transcript.\nStep 2 We now compute the challenges \\(\\beta\\) and \\(\\gamma\\) for the permutation argument from the transcript, one at a time and then push them to the transcript. With these values we can compute the \\(z\\), \\(N\\) and \\(D\\) polynomials.\nExercise 18 Compute \\(\\beta\\) from the transcript and push this value to it. Then compute \\(\\gamma\\) and similarly, push it to the transcript. Finally interpolate values for \\(z, N,D\\) and commit \\(z\\) to the transcript.\nStep 3 We are now going to build a ‚Äúmaster polynomial‚Äù which will encode the gate constraints and the permutation constraints in one, which will be more efficient and equivalent to checking each constrain separately.\nExercise 19 Generate a challenge \\(\\alpha\\) and push it to the transcript. Compute the gates constraing on the blinded polynomials:\n\\[ t\\_gates = qM \\cdot a\\_blind \\cdot b\\_blind + qL \\cdot a\\_blind + qR \\cdot b\\_blind - c\\_blind\\]\nThen compute the \\(L_1\\) function as above and the constraints:\n\\[ t\\_perm\\_start = (z\\_poly - 1) \\cdot L_1\\]\n\\[ t\\_perm\\_step = z\\_poly \\cdot N\\_poly - D\\_poly \\cdot z\\_poly(x \\cdot \\omega)\\]\nCompute the master polynomial:\n\\[ bigt = t\\_gates + \\alpha \\cdot t\\_perm\\_start + \\alpha^2 \\cdot t\\_perm\\_step \\]\nand its quotient:\n\\[ quotient\\_poly = \\frac{bigt}{ZH}\\]\nCommit to \\(quotient\\_poly\\) and push to the transcript.\nStep 5 Now we generate the \\(\\zeta\\) challenge to open \\(a,b,c\\) (blinded) and \\(quotient\\_poly, z\\_poly\\) at \\(\\zeta\\). This will later allow the verifier to independently recompute the constraint polynomials. We also need an opening of \\(z\\_poly\\) at \\(\\zeta \\cdot \\omega\\).\nExercise 20 Compute \\(\\zeta\\) from the transcript and push it. Then compute the evaluations of the blinded \\(a,b,c\\), as well as the quotient polynomial and \\(z\\). Compute the proofs for each of these evaluations.\nFinally we collect all proof artifacts we need to share with the verifier so that they can independently reconstruct the transcript and check the expected values and commitment proofs on their side.\nNow all that is left for the verifier is to reconstruct step by step the transcript and check that everything passes! If you implemented the above exercises correctly, this check should pass.\ndef verify_plonk(proof_dictionary):\n    # 0. Reconstruct transcript\n    transcript = \"\"\n    if (value_a != 0 or value_b != 1):\n        return False, \"Input values are not correct\"\n    # 1. Round 1: commitments to a, b, c\n    for name in ('value_a','value_b','output'):\n        transcript = push(proof_dictionary['evaluations'][name], transcript)    \n    for name in ('c_a','c_b','c_c'):\n        transcript = push(proof_dictionary['commitments'][name], transcript)\n    \n    # 2. Round 2: beta, gamma\n    beta_v = generate_challenge(transcript)\n    if beta_v != proof_dictionary['challenges']['beta']:\n        print(beta_v, proof_dictionary['challenges']['beta'])\n        return False, \"beta mismatch\"\n    transcript = push(beta_v, transcript)\n    \n\n    gamma_v = generate_challenge(transcript)\n    if gamma_v != proof_dictionary['challenges']['gamma']:\n        return False, \"gamma mismatch\"\n    transcript = push(gamma_v, transcript)\n    \n    # append z commitment\n    transcript = push(proof_dictionary['commitments']['c_z'], transcript)\n    \n    # 3. Round 3: alpha\n    alpha_v = generate_challenge(transcript)\n    if alpha_v != proof_dictionary['challenges']['alpha']:\n        return False, \"alpha mismatch\"\n    transcript = push(alpha_v, transcript)\n    \n    # append t commitment\n    transcript = push(proof_dictionary['commitments']['c_t'], transcript)\n    \n    # 4. Round 4: zeta\n    zeta_v = generate_challenge(transcript)\n    if zeta_v != proof_dictionary['challenges']['zeta']:\n        return False, \"zeta mismatch\"\n    transcript = push(zeta_v, transcript)\n    \n    \n    # 5. Pairing checks for each opening\n    checks = [\n        # inputs and output openings\n        ('c_a',          'proof_value_a',         'value_a', œâ),\n        ('c_b',          'proof_value_b',         'value_b',œâ),\n        ('c_c',          'proof_output',         'output',œâ^4),\n        # witness openings\n        ('c_a',          'proof_a',         'a_zeta', zeta_v),\n        ('c_b',          'proof_b',         'b_zeta',zeta_v),\n        ('c_c',          'proof_c',         'c_zeta',zeta_v),\n        # z and t openings\n        ('c_z',          'proof_z',         'z_zeta',zeta_v),\n        ('c_t',          'proof_t',         't_zeta',zeta_v),\n        # z(Œ∂¬∑œâ) for perm check\n        ('c_z',          'proof_z_omega',   'z_zeta_omega',zeta_v* œâ ),\n    ]\n    \n    for (c_key, œÄ_key, b_key, challenge_point) in checks:\n        C = proof_dictionary['commitments'][c_key]\n        œÄ = proof_dictionary['proofs'][œÄ_key]\n        b = proof_dictionary['evaluations'][b_key]\n    \n        if not verification(C, œÄ, challenge_point, b):\n            return False, f\"Pairing check failed for {c_key}\"\n\n    qL_z = qL(zeta_v)\n    qR_z = qR(zeta_v)\n    qM_z = qM(zeta_v)\n    N_z = N_poly(zeta_v)\n    D_z = D_poly(zeta_v)\n\n    # Check 1: Gate constraints\n    \n    t_gates_v = qM_z*a_zeta*b_zeta + qL_z*a_zeta+qR_z*b_zeta-c_zeta\n\n    # Check 2: Permutation constraints\n    L1_z = L1(zeta_v)\n    t_perm_start_v = (z_zeta - 1) * L1_z\n    t_perm_step_v = z_zeta * N_z - D_z * z_zeta_omega\n\n    # Check 3: Quotient constraint\n    # Reconstruct the value of the master polynomial at zeta\n    master_poly_v = t_gates_v + alpha_v * t_perm_start_v + alpha_v**2 * t_perm_step_v\n\n    # Reconstruct the value of the vanishing polynomial at zeta\n    ZH_z = zeta_v**n - 1\n\n    # The final check: Does the master polynomial identity hold?\n    if master_poly_v == t_zeta * ZH_z:\n        print(\"Quotient constraint holds.\")\n    else:\n        return False, \"Quotient constraint check failed!\"    \n\n    return True, \"All checks passed!\"\n\n# --- Example invocation ---\nok, msg = verify_plonk(proof_dictionary)\nprint(\"Verifier result:\", ok, msg)\n\nQuotient constraint holds.\nVerifier result: True All checks passed!",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>8.Fiat Shamir</span>"
    ]
  },
  {
    "objectID": "9_Recap_and_conclusions.html",
    "href": "9_Recap_and_conclusions.html",
    "title": "9.Recap and conclusions",
    "section": "",
    "text": "In this notebook we have introduce PLONK by means of a step by step reconstruction of the main ideas in the original paper. We have taken some liberties regarding the exact details as in the original paper for simplicity of exposition. However we have tried to stay as faithful as possible to the main ideas, while sometimes sacrificing efficiency optimization for clarity of explanation.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>9.Recap and conclusions</span>"
    ]
  }
]